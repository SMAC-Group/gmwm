# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Expected value DR
#' @description This function computes the expected value of a drift process.
#' @param omega A \code{double} corresponding to variance of drift.
#' @param n_ts An \code{int} indicating the length of the time series.
#' @return A \code{vec} containing the expected value of the drift.
#' @examples
#' e_drift(1,200)
e_drift <- function(omega, n_ts) {
    .Call('GMWM_e_drift', PACKAGE = 'GMWM', omega, n_ts)
}

#' @title Second moment DR
#' @description This function computes the second moment of a drift process.
#' @param omega A \code{double} corresponding to variance of drift.
#' @param n_ts An \code{int} indicating the length of the time series.
#' @return A \code{vec} containing the second moment of the drift.
#' @examples
#' m2_drift(1, 200)
m2_drift <- function(omega, n_ts) {
    .Call('GMWM_m2_drift', PACKAGE = 'GMWM', omega, n_ts)
}

#' @title Variance DR
#' @description This function computes the variance of a drift process.
#' @param omega A \code{double} corresponding to variance of drift.
#' @param n_ts An \code{int} indicating the length of the time series.
#' @return A \code{vec} containing the variance of the drift.
#' @examples
#' var_drift(1, 200)
var_drift <- function(omega, n_ts) {
    .Call('GMWM_var_drift', PACKAGE = 'GMWM', omega, n_ts)
}

#' @title Compute Tau-Overlap Allan Variance
#' @description Computation of Tau-Overlap Allan Variance
#' @usage avar_to_cpp(x)
#' @param x A \code{vector} with dimensions N x 1. 
#' @return av A \code{matrix} that contains:
#' \itemize{
#'  \item{Col 1}{The size of the cluster}
#'  \item{Col 2}{The Allan variance}
#'  \item{Col 3}{The error associated with the variance estimation.}
#' }
#' @details
#' Given \eqn{N} equally spaced samples with averaging time \eqn{\tau = n\tau _0}{tau = n*tau_0},
#' where \eqn{n} is an integer such that \eqn{ 1 \le n \le \frac{N}{2}}{1<= n <= N/2}.
#' Therefore, \eqn{n} is able to be selected from \eqn{\left\{ {n|n < \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}}{{n|n< floor(log2(N))}}
#' Then, a sampling of \eqn{m = \left\lfloor {\frac{{N - 1}}{n}} \right\rfloor  - 1} samples exist. 
#' The tau-overlap estimator is given by:
#' 
#' where \eqn{ {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} }.
#' 
#' @author JJB
#' @references Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
#' @examples
#' set.seed(999)
#' # Simulate white noise (P 1) with sigma^2 = 4
#' N = 100000
#' white.noise = rnorm(N, 0, 2)
#' #plot(white.noise,ylab="Simulated white noise process",xlab="Time",type="o")
#' #Simulate random walk (P 4)
#' random.walk = cumsum(0.1*rnorm(N, 0, 2))
#' combined.ts = white.noise+random.walk
#' av_mat = avar_to_cpp(combined.ts)
avar_to_cpp <- function(x) {
    .Call('GMWM_avar_to_cpp', PACKAGE = 'GMWM', x)
}

#' @title Compute Maximal-Overlap Allan Variance using Means
#' @description Computation of Maximal-Overlap Allan Variance
#' @usage avar_mo_cpp(x)
#' @param x A \code{vector} with dimensions N x 1. 
#' @return av A \code{list} that contains:
#' \itemize{
#'  \item{"clusters"}{The size of the cluster}
#'  \item{"allan"}{The Allan variance}
#'  \item{"errors"}{The error associated with the variance estimation.}
#' }
#' @details
#' Given \eqn{N} equally spaced samples with averaging time \eqn{\tau = n\tau _0}{tau = n*tau_0},
#' where \eqn{n} is an integer such that \eqn{ 1 \le n \le \frac{N}{2}}{1<= n <= N/2}.
#' Therefore, \eqn{n} is able to be selected from \eqn{\left\{ {n|n < \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}}{{n|n< floor(log2(N))}}
#' Then, \eqn{M = N - 2n} samples exist. 
#' The Maximal-overlap estimator is given by:
#' \eqn{\frac{1}{{2\left( {N - 2k + 1} \right)}}\sum\limits_{t = 2k}^N {{{\left[ {{{\bar Y}_t}\left( k \right) - {{\bar Y}_{t - k}}\left( k \right)} \right]}^2}} }
#' 
#' where \eqn{ {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} }.
#' @author JJB
#' @references Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
#' @examples
#' set.seed(999)
#' # Simulate white noise (P 1) with sigma^2 = 4
#' N = 100000
#' white.noise = rnorm(N, 0, 2)
#' #plot(white.noise,ylab="Simulated white noise process",xlab="Time",type="o")
#' #Simulate random walk (P 4)
#' random.walk = cumsum(0.1*rnorm(N, 0, 2))
#' combined.ts = white.noise+random.walk
#' av_mat = avar_mo_cpp(combined.ts)
avar_mo_cpp <- function(x) {
    .Call('GMWM_avar_mo_cpp', PACKAGE = 'GMWM', x)
}

arma_adapter <- function(theta, p, q, tau) {
    .Call('GMWM_arma_adapter', PACKAGE = 'GMWM', theta, p, q, tau)
}

jacobian_arma <- function(theta, p, q, tau) {
    .Call('GMWM_jacobian_arma', PACKAGE = 'GMWM', theta, p, q, tau)
}

#' Analytic D matrix for AR(1) process
#' @param phi A \code{double} corresponding to the phi coefficient of an AR(1) process.
#' @param sig2 A \code{double} corresponding to the error term of an AR(1) process.
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{\phi ^2}{sigma^2} and the second column contains the partial derivative with respect to \eqn{\sigma ^2}{sigma^2}
#' @details
#' The haar wavelet variance is given as \eqn{\frac{{\left( {\frac{\tau }{2} - 3{\rho _0} - \frac{{\tau \rho _0^2}}{2} + 4\rho _0^{\frac{\tau }{2} + 1} - \rho _0^{\tau  + 1}} \right)\nu _0^2}}{{\frac{{{\tau ^2}}}{8}{{\left( {1 - {\rho _0}} \right)}^2}\left( {1 - \rho _0^2} \right)}}}{See PDF Manual for equation}
#' Note: \eqn{\phi = \rho}{phi = rho} and \eqn{V _0^2 = \sigma _0^2}{V[0]^2 = sigma[0]^2}.
#' Due to length, the analytical derivations of the AR(1) haar wavelet variance are given in a supplied file within vignette.
#' @author JJB
#' @examples
#' deriv_ar1(.3, 1, 2^(1:5))
deriv_ar1 <- function(phi, sig2, tau) {
    .Call('GMWM_deriv_ar1', PACKAGE = 'GMWM', phi, sig2, tau)
}

#' Analytic second derivative matrix for AR(1) process
#' @param phi A \code{double} corresponding to the phi coefficient of an AR(1) process.
#' @param sig2 A \code{double} corresponding to the error term of an AR(1) process.
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the second partial derivative with respect to \eqn{\phi ^2}{sigma^2} and the second column contains the second partial derivative with respect to \eqn{\sigma ^2}{sigma^2}
#' @details
#' The haar wavelet variance is given as \eqn{\frac{{\left( {\frac{\tau }{2} - 3{\rho _0} - \frac{{\tau \rho _0^2}}{2} + 4\rho _0^{\frac{\tau }{2} + 1} - \rho _0^{\tau  + 1}} \right)\nu _0^2}}{{\frac{{{\tau ^2}}}{8}{{\left( {1 - {\rho _0}} \right)}^2}\left( {1 - \rho _0^2} \right)}}}{See PDF Manual for equation}
#' Note: \eqn{\phi = \rho}{phi = rho} and \eqn{V _0^2 = \sigma _0^2}{V[0]^2 = sigma[0]^2}.
#' Due to length, the analytical derivations of the AR(1) haar wavelet variance are given in a supplied file within vignette.
#' @author JJB
#' @examples
#' deriv_2nd_ar1(.3, 1, 2^(1:5))
deriv_2nd_ar1 <- function(phi, sig2, tau) {
    .Call('GMWM_deriv_2nd_ar1', PACKAGE = 'GMWM', phi, sig2, tau)
}

#' Analytic D matrix for drift process
#' @param omega A \code{double} that is the slope of the drift.
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{\omega _0}{omega[0]}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{{\tau ^2}\omega _0^2}}{2}}{nu^2(tau) = tau^2 omega_0^2 / 2}.
#' Taking the derivative with respect to \eqn{\omega _0^2}{omega_0^2} yields: \eqn{\frac{\partial }{{\partial {\omega _0}}}{\nu ^2}\left( \tau  \right) = {\tau ^2}{\omega _0}}{tau^2 * omega_0}
#' @author JJB
#' @examples
#' deriv_dr(5.3, 2^(1:5))
deriv_dr <- function(omega, tau) {
    .Call('GMWM_deriv_dr', PACKAGE = 'GMWM', omega, tau)
}

#' Analytic second derivative matrix for drift process
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the second partial derivative with respect to \eqn{\omega _0}{omega[0]}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{{\tau ^2}\omega _0^2}}{2}}{nu^2(tau) = tau^2 omega_0^2 / 2}.
#' Taking the derivative with respect to \eqn{\omega _0^2}{omega_0^2} yields: \eqn{\frac{\partial }{{\partial {\omega _0}}}{\nu ^2}\left( \tau  \right) = {\tau ^2}{\omega _0}}{tau^2 * omega_0}
#' Taking second derivative with respect to \eqn{\omega _0^2}{omega_0^2} yields: \eqn{\frac{{{\partial ^2}}}{{\partial \omega _0^2}}{\nu ^2}\left( \tau  \right) = {\tau ^2}}{tau^2}
#' @author JJB
#' @examples
#' deriv_2nd_dr(2^(1:5))
deriv_2nd_dr <- function(tau) {
    .Call('GMWM_deriv_2nd_dr', PACKAGE = 'GMWM', tau)
}

#' Analytic D matrix quantisation noise process
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{Q _0^2}{Q[0]^2}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{3Q_0^2}}{{2{\tau ^2}}}}{nu^2(tau) = 3*Q[0]^2 / 2*tau^2}.
#' Taking the derivative with respect to \eqn{Q _0^2}{Q[0]^2} yields: \deqn{\frac{\partial }{{\partial Q_0^2}}{\nu ^2}\left( \tau  \right) = \frac{3}{{2{\tau ^2}}}}{3/(2*tau^2)}.
#' The second derivative derivative with respect to \eqn{Q _0^2}{Q[0]^2} is then: \deqn{\frac{{{\partial ^2}}}{{\partial Q_0^4}}{\nu ^2}\left( \tau  \right) = 0}{0}.
#' @author JJB
#' @examples
#' deriv_qn(2^(1:5))
deriv_qn <- function(tau) {
    .Call('GMWM_deriv_qn', PACKAGE = 'GMWM', tau)
}

#' Analytic D matrix random walk process
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{\gamma _0^2}{gamma[0]^2}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{\left( {2{\tau ^2} + 1} \right)\gamma _0^2}}{{24\tau }}}{nu^2(tau) = (2*tau^2+1)*gamma^2 / (24*tau)}.
#' Taking the first derivative with respect to \eqn{\gamma _0^2}{gamma_0^2} yields: \deqn{\frac{{{\partial ^2}}}{{\partial \gamma _0^4}}{\nu ^2}\left( \tau  \right) = 0}{(2*tau^2+1) / (24*tau)}
#' The second derivative derivative with respect to \eqn{\gamma _0^2}{gamma[0]^2} is then: \deqn{\frac{{{\partial ^2}}}{{\partial \sigma_0^4}}{\nu ^2}\left( \tau  \right) = 0}{0}.
#' @author JJB
#' @examples
#' deriv_rw(2^(1:5))
deriv_rw <- function(tau) {
    .Call('GMWM_deriv_rw', PACKAGE = 'GMWM', tau)
}

#' Analytic D matrix white noise process
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{\sigma _0^2}{sigma[0]^2}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{\sigma _0^2}}{\tau }}{nu^2(tau) = sigma_0^2 / tau}.
#' Taking the derivative with respect to \eqn{\sigma _0^2}{sigma_0^2} yields: \eqn{\frac{\partial }{{\partial \sigma _0^2}}{\nu ^2}\left( \tau  \right) = \frac{1}{\tau }}{1/tau}
#' @author JJB
#' @examples
#' deriv_wn(2^(1:5))
deriv_wn <- function(tau) {
    .Call('GMWM_deriv_wn', PACKAGE = 'GMWM', tau)
}

#' Analytic D matrix of Processes
#' @description This function computes each process to WV (haar) in a given model.
#' @param theta A \code{vec} containing the list of estimated parameters.
#' @param desc A \code{vector<string>} containing a list of descriptors.
#' @param objdesc A \code{field<vec>} containing a list of object descriptors.
#' @param tau A \code{vec} containing the scales e.g. 2^(1:J)
#' @return A \code{matrix} with the process derivatives going down the column
#' @details
#' Function returns the matrix effectively known as "D"
#' @author JJB
#' @examples
#' deriv_qwn(2^(1:5))
derivative_first_matrix <- function(theta, desc, objdesc, tau) {
    .Call('GMWM_derivative_first_matrix', PACKAGE = 'GMWM', theta, desc, objdesc, tau)
}

#' Analytic D matrix of Processes
#' @description This function computes each process to WV (haar) in a given model.
#' @param theta A \code{vec} containing the list of estimated parameters.
#' @param desc A \code{vector<string>} containing a list of descriptors.
#' @param objdesc A \code{field<vec>} containing a list of object descriptors.
#' @param tau A \code{vec} containing the scales e.g. 2^(1:J)
#' @return A \code{matrix} with the process derivatives going down the column
#' @details
#' Function returns the matrix effectively known as "D"
#' @author JJB
#' @examples
#' #TBA
D_matrix <- function(theta, desc, objdesc, tau, omegadiff) {
    .Call('GMWM_D_matrix', PACKAGE = 'GMWM', theta, desc, objdesc, tau, omegadiff)
}

Rcpp_ARIMA <- function(data, params) {
    .Call('GMWM_Rcpp_ARIMA', PACKAGE = 'GMWM', data, params)
}

#' @title Reverse Subset Column
#' @description Subsets the column by going from high indices to low (the reverse of the supported practice)
#' @usage rev_col_subset(x, start, end)
#' @param x A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting column.
#' @param end A \code{unsigned int} that indicates the ending column.
#' @return x A \code{matrix} with matrix rows displayed in reverse order
#' @details Consider a vector x=[[1,2],[3,4]].
#' By setting \code{start=1} and \code{end=0}, the function would output x=[[2,1],[4,1]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix cols start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow = 2,byrow = TRUE)
#' rev_col_subset(x, 1, 0)
rev_col_subset <- function(x, start, end) {
    .Call('GMWM_rev_col_subset', PACKAGE = 'GMWM', x, start, end)
}

#' @title Reverse Subset Row
#' @description Subsets the row by going from high indices to low (the reverse of the supported practice)
#' @usage rev_row_subset(x, start, end)
#' @param x A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting row.
#' @param end A \code{unsigned int} that indicates the ending row.
#' @return x A \code{matrix} with matrix rows displayed in reversed order
#' @details Consider a vector x=[[1,2],[3,4]], the function would output x=[[3,4],[1,2]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix rows start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow=2,byrow=TRUE)
#' rev_row_subset(x, 1, 0)
rev_row_subset <- function(x, start, end) {
    .Call('GMWM_rev_row_subset', PACKAGE = 'GMWM', x, start, end)
}

#' @title Reverse Armadillo Vector
#' @description Reverses the order of an Armadillo Vector
#' @usage reverse_vec(x)
#' @param x A \code{column vector} of length N
#' @return x A \code{column vector} with its contents reversed.
#' @details Consider a vector x=[1,2,3,4,5], the function would output x=[5,4,3,2,1].
#' @author JJB
#' @examples
#' x = 1:5
#' reverse_vec(x)
reverse_vec <- function(x) {
    .Call('GMWM_reverse_vec', PACKAGE = 'GMWM', x)
}

#' @title Transform an Armadillo field<vec> to a matrix
#' @description Unlists vectors in a field and places them into a matrix
#' @param x A \code{field<vec>}.
#' @return A \code{mat} containing the field elements within a column.
#' @author JJB
#' @examples
#' x=rnorm(100)
#' field_to_matrix(modwt_cpp(x))
field_to_matrix <- function(x) {
    .Call('GMWM_field_to_matrix', PACKAGE = 'GMWM', x)
}

#' @title Accumulation of Armadillo field<vec>
#' @description Sums vectors in a field into a single variable.
#' @param x A \code{field<vec>}.
#' @return An \code{mat} containing the field elements within a column.
#' @author JJB
#' @examples
#' x=rnorm(100)
#' field_to_matrix(modwt_cpp(x))
sum_field_vec <- function(x) {
    .Call('GMWM_sum_field_vec', PACKAGE = 'GMWM', x)
}

master_model <- function() {
    .Call('GMWM_master_model', PACKAGE = 'GMWM')
}

auto_select <- function(data, model_type, alpha, compute_v, K, H, G, robust, eff, bs_optimism) {
    .Call('GMWM_auto_select', PACKAGE = 'GMWM', data, model_type, alpha, compute_v, K, H, G, robust, eff, bs_optimism)
}

#' @title Bootstrap for Matrix V
#' @description Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
#' @param theta A \code{vector} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param objdesc A \code{field<vec>} that contains an object description (e.g. values) of the model.
#' @return A \code{vec} that contains the parameter estimates from GMWM estimator.
#' @details
#' Expand in detail...  
#' @author JJB
#' @keywords internal
#' @examples
#' # Coming soon
cov_bootstrapper <- function(theta, desc, objdesc, N, robust, eff, H, diagonal_matrix) {
    .Call('GMWM_cov_bootstrapper', PACKAGE = 'GMWM', theta, desc, objdesc, N, robust, eff, H, diagonal_matrix)
}

#' @title Bootstrap for Optimism
#' @description Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
#' @param theta A \code{vector} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param objdesc A \code{field<vec>} that contains an object description (e.g. values) of the model.
#' @return A \code{vec} that contains the parameter estimates from GMWM estimator.
#' @details
#' Expand in detail...  
#' @author JJB
#' @keywords internal
#' @examples
#' # Coming soon
optimism_bootstrapper <- function(theta, desc, objdesc, scales, model_type, N, robust, eff, alpha, H) {
    .Call('GMWM_optimism_bootstrapper', PACKAGE = 'GMWM', theta, desc, objdesc, scales, model_type, N, robust, eff, alpha, H)
}

#' @title Bootstrap for Standard Deviations of Theta Estimates
#' @description Using the bootstrap approach, we simulate a model based on user supplied parameters
#' @param theta A \code{vector} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param objdesc A \code{field<vec>} that contains an object description (e.g. values) of the model.
#' @return A \code{vec} that contains the parameter estimates from GMWM estimator.
#' @details
#' Expand in detail...  
#' @author JJB
#' @keywords internal
#' @examples
#' # Coming soon
gmwm_sd_bootstrapper <- function(theta, desc, objdesc, scales, model_type, N, robust, eff, alpha, H) {
    .Call('GMWM_gmwm_sd_bootstrapper', PACKAGE = 'GMWM', theta, desc, objdesc, scales, model_type, N, robust, eff, alpha, H)
}

#' @title Generate the Confidence Interval for GOF Bootstrapped
#' @description yaya
#' @param theta
#' @param psi
#' @param alpha
#' @return A \code{vec} that has the alpha/2.0 quantile and then the 1-alpha/2.0 quantile. 
boot_pval_gof <- function(obj, obj_boot, B = 1000L, alpha = 0.05) {
    .Call('GMWM_boot_pval_gof', PACKAGE = 'GMWM', obj, obj_boot, B, alpha)
}

#' @title Bootstrap for Estimating Both Theta and Theta SD
#' @description Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
#' @param theta A \code{vector} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param objdesc A \code{field<vec>} that contains an object description (e.g. values) of the model.
#' @return A \code{vec} that contains the parameter estimates from GMWM estimator.
#' @details
#' Expand in detail...  
#' @author JJB
#' @keywords internal
#' @examples
#' # Coming soon
gmwm_param_bootstrapper <- function(theta, desc, objdesc, scales, model_type, N, robust, eff, alpha, H) {
    .Call('GMWM_gmwm_param_bootstrapper', PACKAGE = 'GMWM', theta, desc, objdesc, scales, model_type, N, robust, eff, alpha, H)
}

#' @title Bootstrap for Everything!
#' @description Using the bootstrap approach, we simulate a model based on user supplied parameters, obtain the wavelet variance, and then V.
#' @param theta A \code{vector} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param objdesc A \code{field<vec>} that contains an object description (e.g. values) of the model.
#' @return A \code{vec} that contains the parameter estimates from GMWM estimator.
#' @details
#' Expand in detail...  
#' @author JJB
#' @keywords internal
#' @examples
#' # Coming soon
all_bootstrapper <- function(theta, desc, objdesc, scales, model_type, N, robust, eff, alpha, H) {
    .Call('GMWM_all_bootstrapper', PACKAGE = 'GMWM', theta, desc, objdesc, scales, model_type, N, robust, eff, alpha, H)
}

#' @title Absolute Value or Modulus of a Complex Number Squared.
#' @description Computes the squared value of the Modulus.
#' @param x A \code{cx_vec}. 
#' @return A \code{vec} containing the modulus squared for each element.
#' @details Consider a complex number defined as: \eqn{z = x + i y} with real \eqn{x} and \eqn{y},
#' The modulus is defined as: \eqn{r = Mod\left(z\right) = \sqrt{\left(x^2 + y^2\right)}}{r = Mod(z) = sqrt(x^2 + y^2)}
#' This function will return: \eqn{r^2 = Mod\left(z\right)^2 = x^2 + y^2}
#' @examples
#' Mod_squared_cpp(c(1+.5i, 2+1i, 5+9i))
Mod_squared_cpp <- function(x) {
    .Call('GMWM_Mod_squared_cpp', PACKAGE = 'GMWM', x)
}

#' @title Absolute Value or Modulus of a Complex Number.
#' @description Computes the value of the Modulus.
#' @param x A \code{cx_vec}. 
#' @return A \code{vec} containing the modulus for each element.
#' @details Consider a complex number defined as: \eqn{z = x + i y} with real \eqn{x} and \eqn{y},
#' The modulus is defined as: \eqn{r = Mod(z) = \sqrt{(x^2 + y^2)}}
#' @examples
#' Mod_cpp(c(1+.5i, 2+1i, 5+9i))
Mod_cpp <- function(x) {
    .Call('GMWM_Mod_cpp', PACKAGE = 'GMWM', x)
}

#' @title Computes the (MODWT) wavelet covariance matrix
#' @description Calculates the (MODWT) wavelet covariance matrix
#' @param signal_modwt A \code{field<vec>} that contains the modwt decomposition.
#' @param nb_level A \code{integer} that contains the level of decomposition J.
#' @param compute_v A \code{string} that indicates what kind of matrix should be created. Possible options: "diag" or "none"
#' @param robust A \code{boolean} that triggers the use of the robust estimate.
#' @param eff A \code{double} that indicates the efficiency as it relates to an MLE.
#' @return A \code{field<mat>} containing the covariance matrix.
#' @examples
#' \dontrun{
#' x=rnorm(100)
#' decomp = modwt(x)
#' V = compute_cov_cpp(decomp$data, decomp$nlevels, compute_v="diag", robust = TRUE, eff=0.6)
#' }
compute_cov_cpp <- function(signal_modwt, nb_level, compute_v = "diag", robust = TRUE, eff = 0.6) {
    .Call('GMWM_compute_cov_cpp', PACKAGE = 'GMWM', signal_modwt, nb_level, compute_v, robust, eff)
}

#' @title Computes the (MODWT) wavelet covariance matrix using Chi-square confidence interval bounds
#' @description Calculates the (MODWT) wavelet covariance matrix using Chi-square confidence interval bounds
#' @param ci_hi A \code{vec} that contains the upper confidence interval points.
#' @param ci_lo A \code{vec} that contains the lower confidence interval points.
#' @return A diagonal matrix.
#' @examples
#' \dontrun{
#' x=runif(100)
#' y=x+3
#' fast_cov_cpp(y,x)
#' }
fast_cov_cpp <- function(ci_hi, ci_lo) {
    .Call('GMWM_fast_cov_cpp', PACKAGE = 'GMWM', ci_hi, ci_lo)
}

#' @title Discrete Wavelet Transform
#' @description Calculation of the coefficients for the discrete wavelet transformation. 
#' @usage dwt_cpp(x, filter_name, nlevels, boundary)
#' @param x A \code{vector} with dimensions \eqn{N\times 1}{N x 1}. 
#' @param filter_name A \code{string} indicating the filter.
#' @param nlevels An \code{integer}, \eqn{J}, indicating the level of the decomposition.
#' @param boundary A \code{string} indicating the type of boundary method to use. Either \code{boundary="periodic"} or \code{"reflection"}.
#' @return y A \code{field<vec>} that contains the wavelet coefficients for each decomposition level
#' @details
#' Performs a level J decomposition of the time series using the pyramid algorithm
#' @author JJB
#' @examples
#' set.seed(999)
#' x = rnorm(2^8)
#' dwt_cpp(x, "haar", 4, boundary="periodic")
dwt_cpp <- function(x, filter_name = "haar", nlevels = 4L, boundary = "periodic") {
    .Call('GMWM_dwt_cpp', PACKAGE = 'GMWM', x, filter_name, nlevels, boundary)
}

#' @title Maximum Overlap Discrete Wavelet Transform
#' @description Calculation of the coefficients for the discrete wavelet transformation
#' @usage modwt_cpp(x, filter_name, nlevels, boundary)
#' @param x A \code{vector} with dimensions N x 1. 
#' @param filter_name A \code{string} indicating the filter.
#' @param nlevels An \code{integer} indicating the level of the decomposition.
#' @param boundary A \code{string} indicating the type of boundary method to use. Either \code{boundary="periodic"} or \code{"reflection"}.
#' @return y A \code{field<vec>} that contains the wavelet coefficients for each decomposition level
#' @details
#' Performs a level J decomposition of the time series using the pyramid algorithm.
#' Use this implementation to supply custom parameters instead of modwt(x),
#' which serves as a wrapper function.
#' @author JJB
#' @examples
#' set.seed(999)
#' x = rnorm(100)
#' modwt_cpp(x, "haar", 4, boundary="periodic")
modwt_cpp <- function(x, filter_name = "haar", nlevels = 4L, boundary = "periodic") {
    .Call('GMWM_modwt_cpp', PACKAGE = 'GMWM', x, filter_name, nlevels, boundary)
}

#' @title Removal of Boundary Wavelet Coefficients
#' @description Removes the first n wavelet coefficients.
#' @param x A \code{field<vec>} that contains the nlevel decomposition using either modwt or dwt.
#' @param wave_filter A \code{field<vec>} containing filter information. Only "haar" is implemented.
#' @param method A \code{string} to describe the mode. Choose between "modwt" and "dwt"
#' @return A \code{field<vec>} with boundary modwt or dwt taken care of.
#' @details 
#' The vectors are truncated by removing the first n wavelet coefficients. 
#' These vectors are then stored into the field that is returned.
#' Note: As a result, there are no NA's introduced and hence the na.omit is not needed.
#' @examples
#' x=rnorm(100)
#' brick_wall(modwt_cpp(x, "haar", 4, boundary="periodic"), select_filter("haar"), "modwt")
brick_wall <- function(x, wave_filter, method = "modwt") {
    .Call('GMWM_brick_wall', PACKAGE = 'GMWM', x, wave_filter, method)
}

#' @title Generate a white noise process
#' @description Generates a white noise process with variance parameter sigma.
#' @param N An \code{integer} for signal length.
#' @param sigma2 A \code{double} that contains process variance.
#' @return wn A \code{vec} containing the white noise.
#' @examples
#' gen_wn(10, 1.5)
gen_wn <- function(N, sigma2 = 1) {
    .Call('GMWM_gen_wn', PACKAGE = 'GMWM', N, sigma2)
}

#' @title Generate a drift
#' @description Generates a drift sequence with a given slope.
#' @param N An \code{integer} for signal length.
#' @param slope A \code{double} that contains drift slope
#' @return gd A \code{vec} containing the drift.
#' @examples
#' gen_dr(10, 8.2)
gen_dr <- function(N, slope = 5) {
    .Call('GMWM_gen_dr', PACKAGE = 'GMWM', N, slope)
}

#' @title Generate a Quantisation Noise (QN) sequence
#' @description Generate an QN sequence given q2
#' @param N An \code{integer} for signal length.
#' @param q2 A \code{double} that contains autocorrection.
#' @return  A \code{vec} containing the QN process.
#' @details 
#' To generate the quantisation noise, we follow this recipe:
#' First, we generate using a random uniform distribution:
#' \deqn{U_k^*\sim U\left[ {0,1} \right]}{U_k^*~U[0,1]}
#' 
#' Then, we multiple the sequence by \eqn{\sqrt{12}}{sqrt(12)} so:
#' \deqn{{U_k} = \sqrt{12} U_k^*}{U_k = sqrt(12)*U_k^*}
#' 
#' Next, we find the derivative of \eqn{{U_k}}{U_k}
#' \deqn{{{\dot U}_k} = \frac{{{U_{k + \Delta t}} - {U_k}}}{{\Delta t}}}{U_k^. = (U_(k + (delta)t) - U_k)}
#'
#' In this case, we modify the derivative such that:
#' \eqn{{{\dot U}_k}\Delta t = {U_{k + \Delta t}} - {U_k}}{U_k^. * (delta)t = U_{k + (delta)*t} - U_k}
#'
#' Thus, we end up with:
#' \deqn{{x_k} = \sqrt Q {{\dot U}_k}\Delta t}{x_k = sqrt(Q)*U_k^.*(delta)t}
#' \deqn{{x_k} = \sqrt Q \left( {{U_{k + 1}} - {U_k}} \right)}{x_k = sqrt(Q)* (U_(k+1) - U_(k))}
#'
#' @examples
#' gen_qn(10, 5)
gen_qn <- function(N, q2 = .1) {
    .Call('GMWM_gen_qn', PACKAGE = 'GMWM', N, q2)
}

#' @title Generate an AR(1) sequence
#' @description Generate an AR sequence given phi and sig2.
#' @details This needs to be extended to AR(p) see \code{arima.sim} and \code{filter}.
#' @param N An \code{integer} for signal length.
#' @param phi A \code{double} that contains autocorrection.
#' @param sigma2 A \code{double} that contains process variance.
#' @return gm A \code{vec} containing the AR(1) process.
#' @examples
#' gen_ar1(10, 5, 1.2)
gen_ar1 <- function(N, phi = .3, sigma2 = 1) {
    .Call('GMWM_gen_ar1', PACKAGE = 'GMWM', N, phi, sigma2)
}

#' @title Generate a random walk without drift
#' @description Generates a random walk without drift.
#' @param N An \code{integer} for signal length.
#' @param sigma2 A \code{double} that contains process variance.
#' @return grw A \code{vec} containing the random walk without drift.
#' @examples
#' gen_rw(10, 8.2)
gen_rw <- function(N, sigma2 = 1) {
    .Call('GMWM_gen_rw', PACKAGE = 'GMWM', N, sigma2)
}

#' @title Generate ARMA
#' @description Generate observations for a supplied ARMA model.
#' @param N An \code{integer} for signal length.
#' @param ar A \code{vec} that contains the AR coefficients.
#' @param ma A \code{vec} that contains the MA coefficients.
#' @param sigma2 A \code{double} that contains process variance.
#' @param n_start An \code{unsigned int} that indicates the amount of observations to be used for the burn in period. 
#' @details The innovations are generated from a normal distribution.
#' @return A \code{vec} that contains the generated observations.
gen_arma <- function(N, ar, ma, sigma2 = 1.5, n_start = 0L) {
    .Call('GMWM_gen_arma', PACKAGE = 'GMWM', N, ar, ma, sigma2, n_start)
}

#' @title Generate Time Series based on Model (Internal)
#' @description Create a time series based on a supplied time series model.
#' @param N An \code{interger} containing the amount of observations for the time series.
#' @param theta A \code{vec} containing the parameters to use to generate the model
#' @param desc A \code{vector<string>} containing the different model types (AR1, WN, etc..)
#' @param objdesc A \code{field<vec>} contains the different model objects e.g. AR1 = c(1,1)
#' @return A \code{vec} that contains combined time series.
#' @examples
#' # AR
#' set.seed(1336)
#' gen_model(1000, c(.9,1), "AR1", list(c(1,1)))
gen_model <- function(N, theta, desc, objdesc) {
    .Call('GMWM_gen_model', PACKAGE = 'GMWM', N, theta, desc, objdesc)
}

#' @title Generate Latent Time Series based on Model (Internal)
#' @description Create a latent time series based on a supplied time series model.
#' @param N An \code{interger} containing the amount of observations for the time series.
#' @param theta A \code{vec} containing the parameters to use to generate the model.
#' @param desc A \code{vector<string>} containing the different model types (AR1, WN, etc..).
#' @param objdesc A \code{field<vec>} containing the different model objects e.g. AR1 = c(1,1)
#' @return A \code{mat} containing data for each decomposed and combined time series.
#' @examples
#' # AR
#' set.seed(1336)
#' gen_lts(1000, c(.9,1), "AR1", list(c(1,1)))
gen_lts <- function(N, theta, desc, objdesc) {
    .Call('GMWM_gen_lts', PACKAGE = 'GMWM', N, theta, desc, objdesc)
}

code_zero <- function(theta) {
    .Call('GMWM_code_zero', PACKAGE = 'GMWM', theta)
}

#' @title Engine for obtaining the GMWM Estimator
#' @description This function uses the Generalized Method of Wavelet Moments (GMWM) to estimate the parameters of a time series model.
#' @param theta A \code{vec} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param objdesc A \code{field<vec>} containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))
#' @param model_type A \code{string} that represents the model transformation
#' @param wv_empir A \code{vec} that contains the empirical wavelet variance
#' @param omega A \code{mat} that represents the covariance matrix.
#' @param scales A \code{vec} that contains the scales or taus (2^(1:J))
#' @param starting A \code{bool} that indicates whether we guessed starting (T) or the user supplied estimates (F).
#' @return A \code{vec} that contains the parameter estimates from GMWM estimator.
#' @details
#' If type = "sensor" or "ssm", then parameter vector should indicate the characters of the models that compose the latent or state-space model.
#' The model options are:
#' \itemize{
#'   \item{"AR1"}{a first order autoregressive process with parameters \eqn{(\phi,\sigma^2)}{phi, sigma^2}}
#'   \item{"ARMA"}{an autoregressiveß moving average process with parameters \eqn{(\phi _p, \theta _q, \sigma^2)}{phi[p], theta[q], sigma^2}}
#'   \item{"DR"}{a drift with parameter \eqn{\omega}{omega}}
#'   \item{"QN"}{a quantization noise process with parameter \eqn{Q}}
#'   \item{"RW"}{a random walk process with parameter \eqn{\sigma^2}{sigma^2}}
#'   \item{"WN"}{a white noise process with parameter \eqn{\sigma^2}{sigma^2}}
#' }
#' If model_type = "sensor" or type = "ssm" then
#' starting values pass through an initial bootstrap and pseudo-optimization before being passed to the GMWM optimization.
#' If robust = TRUE the function takes the robust estimate of the wavelet variance to be used in the GMWM estimation procedure.
#' 
#' @author JJB
#' @references Wavelet variance based estimation for composite stochastic processes, S. Guerrier and Robust Inference for Time Series Models: a Wavelet-Based Framework, S. Guerrier
#' @keywords internal
#' @examples
#' # Coming soon
gmwm_engine <- function(theta, desc, objdesc, model_type, wv_empir, omega, scales, starting) {
    .Call('GMWM_gmwm_engine', PACKAGE = 'GMWM', theta, desc, objdesc, model_type, wv_empir, omega, scales, starting)
}

#' @title Update Wrapper for the GMWM Estimator
#' @description This function uses information obtained previously (e.g. WV covariance matrix) to re-estimate a different model parameterization
#' @param theta A \code{vec} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param objdesc A \code{field<vec>} containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))
#' @param model_type A \code{string} that represents the model transformation
#' @param wv_empir A \code{vec} that contains the empirical wavelet variance
#' @param omega A \code{mat} that represents the covariance matrix.
#' @param scales A \code{vec} that contains the scales or taus (2^(1:J))
#' @param starting A \code{bool} that indicates whether we guessed starting (T) or the user supplied estimates (F).
#' @return A \code{vec} that contains the parameter estimates from GMWM estimator.
#' @details
#' The function estimates a variety of time series models. If type = "ARMA" then the parameter vector (param) should
#' indicate the order of the AR process and of the MA process (i.e. param = c(AR,MA)). If type = "sensor" or "SSM", then
#' parameter vector should indicate the characters of the models that compose the latent or state-space model. The model
#' options are:
#' \itemize{
#'   \item{"AR1"}{a first order autoregressive process with parameters \eqn{(\phi,\sigma^2)}{phi, sigma^2}}
#'   \item{"ARMA"}{an autoregressiveß moving average process with parameters \eqn{(\phi _p, \theta _q, \sigma^2)}{phi[p], theta[q], sigma^2}}
#'   \item{"DR"}{a drift with parameter \eqn{\omega}{omega}}
#'   \item{"QN"}{a quantization noise process with parameter \eqn{Q}}
#'   \item{"RW"}{a random walk process with parameter \eqn{\sigma^2}{sigma^2}}
#'   \item{"WN"}{a white noise process with parameter \eqn{\sigma^2}{sigma^2}}
#' }
#' If type = "ARMA", the function takes condition least squares as starting values; if type = "sensor" or type = "SSM" then
#' starting values pass through an initial bootstrap and pseudo-optimization before being passed to the GMWM optimization.
#' If robust = TRUE the function takes the robust estimate of the wavelet variance to be used in the GMWM estimation procedure.
#' 
#' @author JJB
#' @references Wavelet variance based estimation for composite stochastic processes, S. Guerrier and Robust Inference for Time Series Models: a Wavelet-Based Framework, S. Guerrier
#' @keywords internal
#' @examples
#' # Coming soon
gmwm_update_cpp <- function(theta, desc, objdesc, model_type, N, expect_diff, orgV, scales, wv_empir, starting, compute_v, K, H, G, robust, eff) {
    .Call('GMWM_gmwm_update_cpp', PACKAGE = 'GMWM', theta, desc, objdesc, model_type, N, expect_diff, orgV, scales, wv_empir, starting, compute_v, K, H, G, robust, eff)
}

#' @title Master Wrapper for the GMWM Estimator
#' @description This function generates WV, GMWM Estimator, and an initial test estimate.
#' @param data A \code{vec} containing the data.
#' @param theta A \code{vec} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param objdesc A \code{field<vec>} containing a list of parameters (e.g. AR(1) = c(1,1), ARMA(p,q) = c(p,q,1))
#' @param model_type A \code{string} that represents the model transformation
#' @param starting A \code{bool} that indicates whether the supplied values are guessed (T) or are user-based (F).
#' @param alpha A \code{double} that handles the alpha level of the confidence interval (1-alpha)*100
#' @param compute_v A \code{string} that describes what kind of covariance matrix should be computed.
#' @param K An \code{int} that controls how many times theta is updated.
#' @param H An \code{int} that controls how many bootstrap replications are done.
#' @param G An \code{int} that controls how many guesses at different parameters are made.
#' @param robust A \code{bool} that indicates whether the estimation should be robust or not.
#' @param eff A \code{double} that specifies the amount of efficiency required by the robust estimator.
#' @param inference A \code{bool} that indicates whether inference should be run on the supplied model.
#' @return A \code{field<mat>} that contains a list of ever-changing estimates...
#' @details
#' The function estimates a variety of time series models. If type = "ARMA" then the parameter vector (param) should
#' indicate the order of the AR process and of the MA process (i.e. param = c(AR,MA)). If type = "sensor" or "SSM", then
#' parameter vector should indicate the characters of the models that compose the latent or state-space model. The model
#' options are:
#' \itemize{
#'   \item{"AR1"}{a first order autoregressive process with parameters \eqn{(\phi,\sigma^2)}{phi, sigma^2}}
#'   \item{"ARMA"}{an autoregressiveß moving average process with parameters \eqn{(\phi _p, \theta _q, \sigma^2)}{phi[p], theta[q], sigma^2}}
#'   \item{"DR"}{a drift with parameter \eqn{\omega}{omega}}
#'   \item{"QN"}{a quantization noise process with parameter \eqn{Q}}
#'   \item{"RW"}{a random walk process with parameter \eqn{\sigma^2}{sigma^2}}
#'   \item{"WN"}{a white noise process with parameter \eqn{\sigma^2}{sigma^2}}
#' }
#' If type = "ARMA", the function takes condition least squares as starting values; if type = "sensor" or type = "SSM" then
#' starting values pass through an initial bootstrap and pseudo-optimization before being passed to the GMWM optimization.
#' If robust = TRUE the function takes the robust estimate of the wavelet variance to be used in the GMWM estimation procedure.
#' 
#' @author JJB
#' @references Wavelet variance based estimation for composite stochastic processes, S. Guerrier and Robust Inference for Time Series Models: a Wavelet-Based Framework, S. Guerrier
#' @keywords internal
#' @examples
#' # Coming soon
gmwm_master_cpp <- function(data, theta, desc, objdesc, model_type, starting, alpha, compute_v, K, H, G, robust, eff) {
    .Call('GMWM_gmwm_master_cpp', PACKAGE = 'GMWM', data, theta, desc, objdesc, model_type, starting, alpha, compute_v, K, H, G, robust, eff)
}

#' @title Randomly guess starting parameters for AR1
#' @description Sets starting parameters for each of the given parameters. 
#' @param draw_id An \code{unsigned int} that contains the draw principles.
#' @param last_phi A \code{double} containing the last guessed phi value.
#' @param sigma2_total A \code{double} that contains the sum of all WVs. 
#' @param model_type A \code{string} that describes the model transformation.
#' @return A \code{vec} containing smart parameter starting guesses to be iterated over.
#' @examples
#' #TBA
ar1_draw <- function(draw_id, last_phi, sigma2_total, model_type) {
    .Call('GMWM_ar1_draw', PACKAGE = 'GMWM', draw_id, last_phi, sigma2_total, model_type)
}

#' @title Randomly guess starting parameters for ARMA
#' @description Sets starting parameters for each of the given parameters. 
#' @param p An \code{unsigned int} that contains the amount of AR parameters to generate.
#' @param q An \code{unsigned int} that contains the amount of MA parameters to generate.
#' @param sigma2_total A \code{double} that contains the sum of all WVs. 
#' @return A \code{vec} containing smart parameter starting guesses to be iterated over.
#' @examples
#' #TBA
arma_draws <- function(p, q, sigma2_total) {
    .Call('GMWM_arma_draws', PACKAGE = 'GMWM', p, q, sigma2_total)
}

#' @title Randomly guess a starting parameter
#' @description Sets starting parameters for each of the given parameters. 
#' @param desc A \code{vector<string>} that contains the model's components.
#' @param objdesc A \code{field<vec>} that contains an object description (e.g. values) of the model.
#' @param model_type A \code{string} that indicates whether it is an SSM or sensor.
#' @param num_param An \code{unsigned int} number of parameters in the model (e.g. # of thetas).
#' @param expect_diff A \code{double} that contains the mean of the first difference of the data
#' @param N A \code{integer} that contains the number of observations in the data.
#' @param wv_empir A \code{vec} that contains the empirical wavelet variance.
#' @param tau A \code{vec} that contains the scales. (e.g. 2^(1:J))
#' @param B A \code{integer} that indicates how many random draws that should be performed.
#' @return A \code{vec} containing smart parameter starting guesses to be iterated over.
#' @examples
#' #TBA
guess_initial <- function(desc, objdesc, model_type, num_param, expect_diff, N, wv_empir, tau, B) {
    .Call('GMWM_guess_initial', PACKAGE = 'GMWM', desc, objdesc, model_type, num_param, expect_diff, N, wv_empir, tau, B)
}

#' @title Indirect Inference for ARMA
idf_arma <- function(ar, ma, sigma2, N, robust, eff, H) {
    .Call('GMWM_idf_arma', PACKAGE = 'GMWM', ar, ma, sigma2, N, robust, eff, H)
}

#' @title Indirect Inference for ARMA
idf_arma_total <- function(ar, ma, sigma2, N, robust, eff, H) {
    .Call('GMWM_idf_arma_total', PACKAGE = 'GMWM', ar, ma, sigma2, N, robust, eff, H)
}

#' @title Calculate the Psi matrix
#' @description Computes the Psi matrix using supplied parameters
#' @param A first derivative matrix
#' @param v_hat bootstrapped V
#' @param omega original omega matrix
#' @return A \code{mat} that has the first column 
calculate_psi_matrix <- function(A, v_hat, omega) {
    .Call('GMWM_calculate_psi_matrix', PACKAGE = 'GMWM', A, v_hat, omega)
}

#' @title Format the Confidence Interval for Estimates
#' @description Creates hi and lo confidence based on SE and alpha.
#' @param theta
#' @param se
#' @param alpha
#' @return A \code{mat} that has:
#' \itemize{
#' \item Column 1: Lo CI
#' \item Column 2: Hi CI
#' \item Column 3: SE
#' }
format_ci <- function(theta, se, alpha) {
    .Call('GMWM_format_ci', PACKAGE = 'GMWM', theta, se, alpha)
}

#' @title Generate the Confidence Interval for Theta Estimates
#' @description yaya
#' @param theta
#' @param psi
#' @param z
#' @return A \code{mat} that has the first column 
theta_ci <- function(theta, A, v_hat, omega, alpha) {
    .Call('GMWM_theta_ci', PACKAGE = 'GMWM', theta, A, v_hat, omega, alpha)
}

#' @title Compute the GOF Test
#' @description yaya
#' @param theta
#' @param psi
#' @param p
#' @return A \code{vec} that has
#' \itemize{
#' \item Test Statistic
#' \item P-Value
#' \item DF
#' } 
gof_test <- function(theta, desc, objdesc, model_type, tau, v_hat, wv_empir) {
    .Call('GMWM_gof_test', PACKAGE = 'GMWM', theta, desc, objdesc, model_type, tau, v_hat, wv_empir)
}

#' @title B Matrix
#' @description B Matrix
#' @param A A \code{mat} containing the first derivatives of the process.
#' @param at_omega A \code{mat} containing A^T * Omega
#' @return A \code{mat}
#' @details
#' TBA
B_matrix <- function(A, at_omega) {
    .Call('GMWM_B_matrix', PACKAGE = 'GMWM', A, at_omega)
}

#' @title Model Score
#' @description Calculates the modeling score of a GMWM
#' @param A A \code{mat} that contains the first derivatives of the processes
#' @param At_j  A \code{mat} that contains the second derivative of each process
#' @param omega A \code{mat} that contains the omega used when calculating the GMWM
#' @param v_hat A \code{mat} that contains the covariance matrix
#' @param diff A \code{vec} that is the difference of the WV empirical and WV theoretical
#' @return A \code{vec}
#' @details
#' The equation is slightly different than that stated in the paper due to the bootstrap already incorporating in 
#' N.
model_score <- function(A, D, omega, v_hat, obj_value) {
    .Call('GMWM_model_score', PACKAGE = 'GMWM', A, D, omega, v_hat, obj_value)
}

#' @title Extract Object
#' @description Extracts the object information and returns it.
#' @param theta A \code{vec} containing the theta values.
#' @param objdesc A \code{vec} at the desc point.
#' @param cur_position An \code{integer} at the current position.
#' @return A \code{field<vec>} containing the breakdown of the object.
obj_extract <- function(theta, objdesc, cur_position) {
    .Call('GMWM_obj_extract', PACKAGE = 'GMWM', theta, objdesc, cur_position)
}

getObjFunStarting <- function(theta, desc, objdesc, model_type, wv_empir, tau) {
    .Call('GMWM_getObjFunStarting', PACKAGE = 'GMWM', theta, desc, objdesc, model_type, wv_empir, tau)
}

getObjFun <- function(theta, desc, objdesc, model_type, omega, wv_empir, tau) {
    .Call('GMWM_getObjFun', PACKAGE = 'GMWM', theta, desc, objdesc, model_type, omega, wv_empir, tau)
}

#' @title Root Finding C++
#' @description Used to interface with Armadillo
do_polyroot_arma <- function(z) {
    .Call('GMWM_do_polyroot_arma', PACKAGE = 'GMWM', z)
}

#' @title Root Finding C++
#' @description Vroom Vroom
do_polyroot_cpp <- function(z) {
    .Call('GMWM_do_polyroot_cpp', PACKAGE = 'GMWM', z)
}

#' @title ARMA process to WV
#' @description This function computes the (haar) WV of an ARMA process
#' @param ar A \code{vec} containing the coefficients of the AR process
#' @param ma A \code{vec} containing the coefficients of the MA process
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @param sigma A \code{double} containing the residual variance
#' @return A \code{vec} containing the wavelet variance of the ARMA process.
#' @examples
#' arma_to_wv(c(.23,.43), c(.34,.41,.59), 2^(1:9), 3)
#' @seealso \code{\link{ARMAtoMA_cpp}},\code{\link{ARMAacf_cpp}}
arma_to_wv <- function(ar, ma, tau, sigma) {
    .Call('GMWM_arma_to_wv', PACKAGE = 'GMWM', ar, ma, tau, sigma)
}

acf_sum <- function(ar, ma, last_tau, alpha = 0.99) {
    .Call('GMWM_acf_sum', PACKAGE = 'GMWM', ar, ma, last_tau, alpha)
}

#' @title ARMA process to WV approximation
#' @description This function computes the (haar) WV of an ARMA process
#' @param ar A \code{vec} containing the coefficients of the AR process
#' @param ma A \code{vec} containing the coefficients of the MA process
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @param sigma A \code{double} containing the residual variance
#' @return A \code{vec} containing the wavelet variance of the ARMA process.
#' @examples
#' arma_to_wv(c(.23,.43), c(.34,.41,.59), 2^(1:9), 3)
#' @seealso \code{\link{ARMAtoMA_cpp}},\code{\link{ARMAacf_cpp}}
arma_to_wv_app <- function(ar, ma, tau, sigma, alpha = 0.9999) {
    .Call('GMWM_arma_to_wv_app', PACKAGE = 'GMWM', ar, ma, tau, sigma, alpha)
}

#' @title Quantisation Noise to WV
#' @description This function compute the WV (haar) of a Quantisation Noise (QN) process
#' @param q2 A \code{double} corresponding to variance of drift
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the QN.
#' @examples
#' x.sim = 1:1000
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = qn_to_wv(1, tau)
#' plot(tau, wv.theo, col = "red")
qn_to_wv <- function(q2, tau) {
    .Call('GMWM_qn_to_wv', PACKAGE = 'GMWM', q2, tau)
}

#' @title White Noise to WV
#' @description This function compute the WV (haar) of a White Noise process
#' @param sig2 A \code{double} corresponding to variance of WN
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the white noise.
#' @examples
#' x.sim = cumsum(rnorm(100000))
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = wn_to_wv(1, tau)
#' plot(tau, wv.theo, col = "red")
wn_to_wv <- function(sig2, tau) {
    .Call('GMWM_wn_to_wv', PACKAGE = 'GMWM', sig2, tau)
}

#' @title Random Walk to WV
#' @description This function compute the WV (haar) of a Random Walk process
#' @param sig2 A \code{double} corresponding to variance of RW
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the random walk.
#' @examples
#' x.sim = cumsum(rnorm(100000))
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = rw_to_wv(1,tau)
#' plot(tau, wv.theo, col = "red")
rw_to_wv <- function(sig2, tau) {
    .Call('GMWM_rw_to_wv', PACKAGE = 'GMWM', sig2, tau)
}

#' @title Drift to WV
#' @description This function compute the WV (haar) of a Drift process
#' @param omega A \code{double} corresponding to variance of drift
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the drift.
#' @examples
#' x.sim = 1:1000
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = dr_to_wv(1, tau)
#' plot(tau, wv.theo, col = "red")
dr_to_wv <- function(omega, tau) {
    .Call('GMWM_dr_to_wv', PACKAGE = 'GMWM', omega, tau)
}

#' @title AR1 process to WV
#' @description This function compute the WV (haar) of an AR(1) process
#' @param phi A \code{double} that is the phi term of the AR(1) process
#' @param sig2 A \code{double} corresponding to variance of AR(1) process
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the AR(1) process.
#' @examples
#' x.sim = gen_ar1( N = 10000, phi = 0.9, sigma2 = 4 )
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = ar1_to_wv(phi = 0.9, sig2 = 16, tau)
#' plot(tau, wv.theo, col = "red")
ar1_to_wv <- function(phi, sig2, tau) {
    .Call('GMWM_ar1_to_wv', PACKAGE = 'GMWM', phi, sig2, tau)
}

#' @title Model Process to WV
#' @description This function computes the summation of all Processes to WV (haar) in a given model
#' @param theta A \code{vec} containing the list of estimated parameters.
#' @param desc A \code{vector<string>} containing a list of descriptors.
#' @param objdesc A \code{field<vec>} containing a list of object descriptors.
#' @param tau A \code{vec} containing the scales e.g. 2^(1:J)
#' @return A \code{vec} containing the wavelet variance of the model.
#' @examples
#' x.sim = gen_ar1( N = 10000, phi = 0.9, sigma2 = 4 )
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = ar1_to_wv(phi = 0.9, sig2 = 16, tau)
#' plot(tau, wv.theo, col = "red")
theoretical_wv <- function(theta, desc, objdesc, tau) {
    .Call('GMWM_theoretical_wv', PACKAGE = 'GMWM', theta, desc, objdesc, tau)
}

#' @title Each Models Process Decomposed to WV
#' @description This function computes each process to WV (haar) in a given model.
#' @param theta A \code{vec} containing the list of estimated parameters.
#' @param desc A \code{vector<string>} containing a list of descriptors.
#' @param objdesc A \code{field<vec>} containing a list of object descriptors.
#' @param tau A \code{vec} containing the scales e.g. 2^(1:J)
#' @return A \code{mat} containing the wavelet variance of each process in the model
#' @examples
#' x.sim = gen_ar1( N = 10000, phi = 0.9, sigma2 = 4 )
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = ar1_to_wv(phi = 0.9, sig2 = 16, tau)
#' plot(tau, wv.theo, col = "red")
decomp_theoretical_wv <- function(theta, desc, objdesc, tau) {
    .Call('GMWM_decomp_theoretical_wv', PACKAGE = 'GMWM', theta, desc, objdesc, tau)
}

#' @title Decomposed WV to Single WV
#' @description This function computes the combined processes to WV (haar) in a given model.
#' @param decomp A \code{mat} with scales as rows and processes as columns
#' @return A \code{vec} containing the wavelet variance of the process for the overall model
#' @examples
#' x.sim = gen_ar1( N = 10000, phi = 0.9, sigma2 = 4 )
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = ar1_to_wv(phi = 0.9, sig2 = 16, tau)
#' plot(tau, wv.theo, col = "red")
decomp_to_theo_wv <- function(decomp) {
    .Call('GMWM_decomp_to_theo_wv', PACKAGE = 'GMWM', decomp)
}

#' Read an IMU Binary File into R
#' 
#' The function will take a file location in addition to the type of sensor it
#' came from and read the data into R.
#' 
#' @param file_path A \code{string} that contains the full file path.
#' @param imu_type A \code{string} that contains a supported IMU type given below.
#' @details
#' Currently supports the following IMUs:
#' \itemize{
#' \item IMAR
#' \item LN200
#' \item LN200IG
#' \item IXSEA
#' \item NAVCHIP_INT
#' \item NAVCHIP_FLT
#' }
#' 
#' We hope to soon be able to support delimited files.
#' @return A matrix with dimensions N x 7, where the columns represent:
#' \describe{
#' \item{Col 0}{Time}
#' \item{Col 1}{Gyro 1}
#' \item{Col 2}{Gyro 2}
#' \item{Col 3}{Gyro 3}
#' \item{Col 4}{Accel 1}
#' \item{Col 5}{Accel 2}
#' \item{Col 6}{Accel 3}
#' }
#' @references
#' Thanks goes to Philipp Clausen of Labo TOPO, EPFL, Switzerland, topo.epfl.ch, Tel:+41(0)21 693 27 55
#' for providing a matlab function that reads in IMUs.
#' The function below is a heavily modified port of MATLAB code into Armadillo/C++. 
#' 
#' @examples
#' read_imu("F:/Desktop/short_test_data.imu","IXSEA")
read_imu <- function(file_path, imu_type) {
    .Call('GMWM_read_imu', PACKAGE = 'GMWM', file_path, imu_type)
}

#' @title Generate a sequence of values
#' @description Creates a vector containing a sequence of values starting at the initial point and going to the terminal point.
#' @param a An \code{int}, that denotes the starting point.
#' @param b An \code{int}, that denotes the ending point.
#' @return A \code{vector} containing values moving from a to b. There are no restrictions on A's range.
#' @seealso \code{\link{rwishart}} 
#' @author James J Balamuta
#' @examples 
#' #Call with the following data:
#' seq_cpp(3, 5)
#' seq_cpp(5, 3)
seq_cpp <- function(a, b) {
    .Call('GMWM_seq_cpp', PACKAGE = 'GMWM', a, b)
}

#' @title Generate a sequence of values based on supplied number
#' @description Creates a vector containing a sequence of values starting at 1 and going to the terminal point.
#' @param n An \code{int} that denotes the length of the vector.
#' @return A \code{vector} containing values moving from 1 to n.
#' @author James J Balamuta
#' @examples 
#' #Call with the following data:
#' seq_len_cpp(5)
seq_len_cpp <- function(n) {
    .Call('GMWM_seq_len_cpp', PACKAGE = 'GMWM', n)
}

#' @title Find Quantiles
#' @description Attempts to find quantiles
#' @param x A \code{vec} that denotes the starting point.
#' @param b A \code{vec}, that denotes the ending point.
#' @return A \code{vector} containing the quantiles
#' @author James J Balamuta
#' @examples 
#' #Call with the following data:
#' quantile_cpp(c(1,2,3,4,5,6,7), c(.25,.5,.75))
#' quantile(c(1,2,3,4,5,6,7), c(.25,.5,.75))
quantile_cpp <- function(x, probs) {
    .Call('GMWM_quantile_cpp', PACKAGE = 'GMWM', x, probs)
}

#' @title Lagged Differences in Armadillo
#' @description Returns the ith difference of a time series of rth lag.
#' @param x A \code{vec} that is the time series
#' @param lag A \code{unsigned int} that indicates the lag
#' @param differences A \code{dif} that indicates how many differences should be taken
#' @return A \code{vector} containing the differenced time series.
#' @author JJB
#' @examples
#' x = rnorm(10000, 0, 1)
#' diff_cpp(x,1,1)
diff_cpp <- function(x, lag, differences) {
    .Call('GMWM_diff_cpp', PACKAGE = 'GMWM', x, lag, differences)
}

#' @title Converting an ARMA Process to an Infinite MA Process
#' @description Takes an ARMA function and converts it to an infinite MA process.
#' @param ar A \code{column vector} of length p
#' @param ma A \code{column vector} of length q
#' @param lag_max A \code{int} of the largest MA(Inf) coefficient required.
#' @return A \code{column vector} containing coefficients
#' @details This function is a port of the base stats package's ARMAtoMA. There is no significant speed difference between the two.
#' @author R Core Team and JJB
#' @examples
#' # ARMA(2,1)
#' ARMAtoMA_cpp(c(1.0, -0.25), 1.0, 10)
#' # ARMA(0,1)
#' ARMAtoMA_cpp(numeric(0), 1.0, 10)
ARMAtoMA_cpp <- function(ar, ma, lag_max) {
    .Call('GMWM_ARMAtoMA_cpp', PACKAGE = 'GMWM', ar, ma, lag_max)
}

#' @title Time Series Convolution Filters
#' @description Applies a convolution filter to a univariate time series.
#' @param x A \code{column vector} of length T
#' @param filter A \code{column vector} of length f
#' @param sides An \code{int} that takes either 1:for using past values only or 2: filter coefficients are centered around lag 0.
#' @param circular A \code{bool} that indicates if the filter should be wrapped around the ends of the time series.
#' @return A \code{column vec} that contains the results of the filtering process.
#' @details This is a port of the cfilter function harnessed by the filter function in stats. 
#' It is about 5-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' x = 1:100
#' # 
#' cfilter(x, rep(1, 3), sides = 2, circular = FALSE)
#' # Using R's function
#' filter(x, rep(1, 3))
#' #
#' cfilter(x, rep(1, 3), sides = 1, circular = FALSE)
#' # Using R's function
#' filter(x, rep(1, 3), sides = 1)
#' #
#' cfilter(x, rep(1, 3), sides = 1, circular = TRUE)
#' # Using R's function
#' filter(x, rep(1, 3), sides = 1, circular = TRUE)
cfilter <- function(x, filter, sides, circular) {
    .Call('GMWM_cfilter', PACKAGE = 'GMWM', x, filter, sides, circular)
}

#' @title Time Series Recursive Filters
#' @description Applies a recursive filter to a univariate time series.
#' @usage rfilter(x, filter, init)
#' @param x A \code{column vector} of length T
#' @param filter A \code{column vector} of length f
#' @param init A \code{column vector} of length f that contains the initial values of the time series in reverse.
#' @return x A \code{column vector} with its contents reversed.
#' @details Note: The length of 'init' must be equal to the length of 'filter'.
#' This is a port of the rfilter function harnessed by the filter function in stats. 
#' It is about 6-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' x = 1:100
#' # 
#' rfilter(x, rep(1, 3), rep(1, 3))
#' # Using R's function
#' filter(x, rep(1, 3), method="recursive", init=rep(1, 3))
rfilter <- function(x, filter, init) {
    .Call('GMWM_rfilter', PACKAGE = 'GMWM', x, filter, init)
}

#' @title Compute Theoretical ACF for an ARMA Process
#' @description Compute the theoretical autocorrelation function for an ARMA process.
#' @usage ARMAacf_cpp(ar,ma,lag_max)
#' @param ar A \code{vector} of length p containing AR coefficients
#' @param ma A \code{vector} of length q containing MA coefficients
#' @param lag_max A \code{unsigned integer} indicating the maximum lag necessary
#' @return x A \code{matrix} listing values from 1...nx in one column and 1...1, 2...2,....,n...n, in the other
#' @details This is an implementaiton of the ARMAacf function in R. It is approximately 40x times faster. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' # ARMA(2,1)
#' ARMAacf_cpp(c(1.0, -0.25), 1.0, lag_max = 10)
#' # ARMA(0,1)
#' ARMAacf_cpp(numeric(0), .35, lag_max = 10)
ARMAacf_cpp <- function(ar, ma, lag_max) {
    .Call('GMWM_ARMAacf_cpp', PACKAGE = 'GMWM', ar, ma, lag_max)
}

#' @title Discrete Fourier Transformation for Autocovariance Function
#' @description Calculates the autovariance function (ACF) using Discrete Fourier Transformation.
#' @param x A \code{cx_vec}. 
#' @return A \code{vec} containing the ACF.
#' @details 
#' This implementation is 2x as slow as Rs. 
#' Two issues: 1. memory resize and 2. unoptimized fft algorithm in arma.
#' Consider piping back into R and rewrapping the object. (Decrease of about 10 microseconds.)
#' @examples
#' x=rnorm(100)
#' dft_acf(x)
dft_acf <- function(x) {
    .Call('GMWM_dft_acf', PACKAGE = 'GMWM', x)
}

mean_diff <- function(x) {
    .Call('GMWM_mean_diff', PACKAGE = 'GMWM', x)
}

get_summary <- function(theta, desc, objdesc, model_type, wv_empir, theo, scales, V, omega, obj_value, N, alpha, robust, eff, inference, fullV, bs_gof, bs_gof_p_ci, bs_theta_est, bs_ci, B) {
    .Call('GMWM_get_summary', PACKAGE = 'GMWM', theta, desc, objdesc, model_type, wv_empir, theo, scales, V, omega, obj_value, N, alpha, robust, eff, inference, fullV, bs_gof, bs_gof_p_ci, bs_theta_est, bs_ci, B)
}

#' @title Pseudo Logit Inverse Function
#' @description This function computes the pseudo inverse of a logit transformation of the parameters in order to constrain them to a positive domain 
#' @param x A \code{vec} containing real numbers.
#' @return A \code{vec} containing logit probabilities.
#' @examples
#' x.sim = rnorm(100)
#' pseudo_logit_inv(x.sim)
pseudo_logit_inv <- function(x) {
    .Call('GMWM_pseudo_logit_inv', PACKAGE = 'GMWM', x)
}

#' @title Logit Inverse Function
#' @description This function computes the inverse of a logit transformation of the parameters.
#' @param x A \code{vec} containing real numbers.
#' @return A \code{vec} containing logit probabilities.
#' @examples
#' x.sim = rnorm(100)
#' logit_inv(x.sim)
logit_inv <- function(x) {
    .Call('GMWM_logit_inv', PACKAGE = 'GMWM', x)
}

#' @title Pseudo Logit Function
#' @description This function compute the link function to constrain parameters to a positive domain.
#' @param x A \code{vec} containing probabilities (e.g. 0 <= x <= 1)
#' @return A \code{vec} containing logit terms.
#' @examples
#' x.sim = runif(100)
#' pseudo_logit(x.sim)
pseudo_logit <- function(x) {
    .Call('GMWM_pseudo_logit', PACKAGE = 'GMWM', x)
}

#' @title Logit Function
#' @description This function computes the logit link function.
#' @param x A \code{vec} containing probabilities (e.g. -1 <= x <= 1)
#' @return A \code{vec} containing logit terms.
#' @examples
#' x.sim = runif(100)
#' logit(x.sim)
logit <- function(x) {
    .Call('GMWM_logit', PACKAGE = 'GMWM', x)
}

#' @title Logit Function
#' @description This function computes the logit link function.
#' @param x A \code{vec} containing probabilities (e.g. -1 <= x <= 1)
#' @return A \code{vec} containing logit terms.
#' @examples
#' x.sim = runif(100)
#' logit(x.sim)
logit2 <- function(x) {
    .Call('GMWM_logit2', PACKAGE = 'GMWM', x)
}

#' @title Logit2 Inverse Function
#' @description This function computes the inverse of a logit transformation of the parameters.
#' @param x A \code{vec} containing real numbers.
#' @return A \code{vec} containing logit probabilities.
#' @examples
#' x.sim = rnorm(100)
#' logit_inv(x.sim)
logit2_inv <- function(x) {
    .Call('GMWM_logit2_inv', PACKAGE = 'GMWM', x)
}

#' @title Transform Values for Optimization
#' @description Transform parameter guesses prior to estimating with GMWM
#' @return A \code{vec} containing the transformed guesses.
transform_values <- function(theta, desc, objdesc, model_type) {
    .Call('GMWM_transform_values', PACKAGE = 'GMWM', theta, desc, objdesc, model_type)
}

#' @title Revert Transform Values for Display
#' @description Undo the previous transform of parameter guesses to obtain the GMWM estimates.
#' @return A \code{vec} containing the undone transformation of parameters.
untransform_values <- function(theta, desc, objdesc, model_type) {
    .Call('GMWM_untransform_values', PACKAGE = 'GMWM', theta, desc, objdesc, model_type)
}

minroot <- function(x) {
    .Call('GMWM_minroot', PACKAGE = 'GMWM', x)
}

#' @title Check Invertibility Conditions
#' @description Checks the invertiveness of series of coefficients.
#' @param x A \code{cx_vec} that has a 1 appended before the coefficents. (e.g. c(1, x))
#' @return True (if outside unit circle) || False (if inside unit circle)
invert_check <- function(x) {
    .Call('GMWM_invert_check', PACKAGE = 'GMWM', x)
}

#' @title Count Models
#' @description Count the amount of models that exist.
#' @param desc A \code{vector<string>} that contains the model's components.
#' @return A \code{map<string, int>} containing how frequent the model component appears.
#' @examples
#' #TBA
count_models <- function(desc) {
    .Call('GMWM_count_models', PACKAGE = 'GMWM', desc)
}

order_AR1s <- function(theta, desc, objdesc) {
    .Call('GMWM_order_AR1s', PACKAGE = 'GMWM', theta, desc, objdesc)
}

model_objdesc <- function(desc) {
    .Call('GMWM_model_objdesc', PACKAGE = 'GMWM', desc)
}

model_theta <- function(desc) {
    .Call('GMWM_model_theta', PACKAGE = 'GMWM', desc)
}

#' @title Generate eta3 confidence interval
#' @description Computes the eta3 CI
#' @param y A \code{vec} that computes the brickwalled modwt dot product of each wavelet coefficient divided by their length.
#' @param dims A \code{String} indicating the confidence interval being calculated.
#' @param alpha_ov_2 A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level 
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @examples
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, "haar", 4, "periodic")
#' signal_modwt_bw = brick_wall(decomp, select_filter("haar"), "modwt")
#' y = wave_variance(signal_modwt_bw)
#' ci_wave_variance(signal_modwt_bw, y, type = "eta3", p = 0.025)
ci_eta3 <- function(y, dims, alpha_ov_2) {
    .Call('GMWM_ci_eta3', PACKAGE = 'GMWM', y, dims, alpha_ov_2)
}

#' @title Generate eta3 robust confidence interval
#' @description Computes the eta3 robust CI
#' @param y A \code{vec} that computes the brickwalled modwt dot product of each wavelet coefficient divided by their length.
#' @param dims A \code{String} indicating the confidence interval being calculated.
#' @param alpha_ov_2 A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level
#' @param eff A \code{double} that indicates the efficiency.
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Robust Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @examples
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, "haar", 4, boundary="periodic")
#' signal_modwt_bw = brick_wall(decomp, select_filter("haar"), "modwt")
#' y = wave_variance(signal_modwt_bw, robust = TRUE,  eff = 0.6)
#' ci_wave_variance(signal_modwt_bw, y, type = "eta3", alpha_ov_2 = 0.025, robust = TRUE, eff = 0.6)
ci_eta3_robust <- function(y, dims, alpha_ov_2, eff) {
    .Call('GMWM_ci_eta3_robust', PACKAGE = 'GMWM', y, dims, alpha_ov_2, eff)
}

#' @title Generate a Confidence intervval for a Univariate Time Series
#' @description Computes an estimate of the multiscale variance and a chi-squared confidence interval
#' @param signal_modwt_bw A \code{field<vec>} that contains the brick walled modwt or dwt decomposition
#' @param y A \code{vec} that contains the wave variance.
#' @param type A \code{String} indicating the confidence interval being calculated.
#' @param alpha_ov_2 A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level.
#' @param robust A \code{boolean} to determine the type of wave estimation.
#' @param eff A \code{double} that indicates the efficiency.
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @details 
#' This function can be expanded to allow for other confidence interval calculations.
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, "haar", 4, boundary="periodic")
#' signal_modwt_bw = brick_wall(decomp, select_filter("haar"), "modwt")
#' y = wave_variance(signal_modwt_bw)
#' ci_wave_variance(signal_modwt_bw, y, type = "eta3", p = 0.025)
ci_wave_variance <- function(signal_modwt_bw, y, type = "eta3", alpha_ov_2 = 0.025, robust = FALSE, eff = 0.6) {
    .Call('GMWM_ci_wave_variance', PACKAGE = 'GMWM', signal_modwt_bw, y, type, alpha_ov_2, robust, eff)
}

#' @title Generate a Wave Variance for a Univariate Time Series
#' @description Computes an estimate of the wave variance
#' @param signal_modwt_bw A \code{field<vec>} that contains the brick walled modwt or dwt decomposition
#' @param robust A \code{boolean} to determine the type of wave estimation.
#' @param eff A \code{double} that indicates the efficiency.
#' @return A \code{vec} that contains the wave variance.
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' signal_modwt_bw = brick_wall(modwt_cpp(x), haar_filter())
#' wave_variance(signal_modwt_bw)
#' 
#' wave_variance(signal_modwt_bw, robust = TRUE, eff = 0.6)
wave_variance <- function(signal_modwt_bw, robust = FALSE, eff = 0.6) {
    .Call('GMWM_wave_variance', PACKAGE = 'GMWM', signal_modwt_bw, robust, eff)
}

#' @title Computes the (MODWT) wavelet variance
#' @description Calculates the (MODWT) wavelet variance
#' @param signal_modwt A \code{field<vec>} that contains the modwt decomposition.
#' @param robust A \code{boolean} that triggers the use of the robust estimate.
#' @param eff A \code{double} that indicates the efficiency as it relates to an MLE.
#' @param alpha A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level 
#' @param ci_type A \code{String} indicating the confidence interval being calculated. Valid value: "eta3"
#' @param strWavelet A \code{String} indicating the type of wave filter to be applied. Must be "haar"
#' @return A \code{mat} with the structure:
#' \itemize{
#'   \item{"variance"}{Wavelet Variance}
#'   \item{"low"}{Lower CI}
#'   \item{"high"}{Upper CI}
#' }
#' @details 
#' This function powers the wvar object. It is also extendable...
#' @examples
#' x=rnorm(100)
#' decomp = modwt(x)
#' wvar_cpp(decomp$data, robust = FALSE)
wvar_cpp <- function(signal_modwt, robust = FALSE, eff = 0.6, alpha = 0.05, ci_type = "eta3", strWavelet = "haar") {
    .Call('GMWM_wvar_cpp', PACKAGE = 'GMWM', signal_modwt, robust, eff, alpha, ci_type, strWavelet)
}

#' @title Computes the MODWT scales
#' @description Calculates the MODWT scales
#' @param nb_level A \code{integer} that contains the level of decomposition J.
#' @return A \code{vec} that contains 2^1, ... , 2^J
#' @details 
#' Used in wvar object.
#' @examples
#' scales_cpp(5)
scales_cpp <- function(nb_level) {
    .Call('GMWM_scales_cpp', PACKAGE = 'GMWM', nb_level)
}

#' @title Quadrature Mirror Filter
#' @description Calculate the series quadrature mirror filter (QMF). Requires a series of an even length.
#' @usage qmf(g, inverse)
#' @param g A \code{vector} that contains the filter constants.
#' @param inverse A \code{bool} that indicates whether the inverse quadrature mirror filter is computed. 
#' By default, the inverse quadrature mirror is computed.
#' @return A \code{vector} that contains either the forward QMF (evalute in order) or the inverse QMF (reverse order). 
#' @author JJB
#' @examples
#' # Haar values
#' g = rep(1/sqrt(2),2)
#' qmf(g)
qmf <- function(g, inverse = TRUE) {
    .Call('GMWM_qmf', PACKAGE = 'GMWM', g, inverse)
}

#' @title Haar filter construction
#' @description Creates the haar filter
#' @usage haar_filter()
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @examples
#' haar_filter()
haar_filter <- function() {
    .Call('GMWM_haar_filter', PACKAGE = 'GMWM')
}

#' @title Select the Wavelet Filter
#' @description Constructs the wavelet filter to be used.
#' @usage select_filter(filter_name)
#' @param filter_name A \code{String} that must receive: \code{"haar"}.
#' @return info A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details 
#' The package is oriented toward using only the haar filter. If the package extends at a later time, then the supporting infrastructure is there.
#' @author JJB
#' @examples
#' select_filter("haar")
select_filter <- function(filter_name = "haar") {
    .Call('GMWM_select_filter', PACKAGE = 'GMWM', filter_name)
}

