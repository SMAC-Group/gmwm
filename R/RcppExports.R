# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Expected value DR
#' @description This function computes the expected value of a drift process.
#' @param omega A \code{double} corresponding to variance of drift.
#' @param n_ts An \code{int} indicating the length of the time series.
#' @return A \code{vec} containing the expected value of the drift.
#' @examples
#' e_drift(1,200)
e_drift <- function(omega, n_ts) {
    .Call('GMWM_e_drift', PACKAGE = 'GMWM', omega, n_ts)
}

#' @title Second moment DR
#' @description This function computes the second moment of a drift process.
#' @param omega A \code{double} corresponding to variance of drift.
#' @param n_ts An \code{int} indicating the length of the time series.
#' @return A \code{vec} containing the second moment of the drift.
#' @examples
#' m2_drift(1, 200)
m2_drift <- function(omega, n_ts) {
    .Call('GMWM_m2_drift', PACKAGE = 'GMWM', omega, n_ts)
}

#' @title Variance DR
#' @description This function computes the variance of a drift process.
#' @param omega A \code{double} corresponding to variance of drift.
#' @param n_ts An \code{int} indicating the length of the time series.
#' @return A \code{vec} containing the variance of the drift.
#' @examples
#' var_drift(1, 200)
var_drift <- function(omega, n_ts) {
    .Call('GMWM_var_drift', PACKAGE = 'GMWM', omega, n_ts)
}

#' @title Compute Tau-Overlap Allan Variance
#' @description Computation of Tau-Overlap Allan Variance
#' @usage avar_to_cpp(x)
#' @param x A \code{vector} with dimensions N x 1. 
#' @return av A \code{matrix} that contains:
#' \itemize{
#'  \item{Col 1}{The size of the cluster}
#'  \item{Col 2}{The Allan variance}
#'  \item{Col 3}{The error associated with the variance estimation.}
#' }
#' @details
#' Given \eqn{N} equally spaced samples with averaging time \eqn{\tau = n\tau _0}{tau = n*tau_0},
#' where \eqn{n} is an integer such that \eqn{ 1 \le n \le \frac{N}{2}}{1<= n <= N/2}.
#' Therefore, \eqn{n} is able to be selected from \eqn{\left\{ {n|n < \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}}{{n|n< floor(log2(N))}}
#' Then, a sampling of \eqn{m = \left\lfloor {\frac{{N - 1}}{n}} \right\rfloor  - 1} samples exist. 
#' The tau-overlap estimator is given by:
#' 
#' where \eqn{ {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} }.
#' 
#' @author JJB
#' @references Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
#' @examples
#' set.seed(999)
#' # Simulate white noise (P 1) with sigma^2 = 4
#' N = 100000
#' white.noise = rnorm(N, 0, 2)
#' #plot(white.noise,ylab="Simulated white noise process",xlab="Time",type="o")
#' #Simulate random walk (P 4)
#' random.walk = cumsum(0.1*rnorm(N, 0, 2))
#' combined.ts = white.noise+random.walk
#' av_mat = avar_to_cpp(combined.ts)
avar_to_cpp <- function(x) {
    .Call('GMWM_avar_to_cpp', PACKAGE = 'GMWM', x)
}

#' @title Compute Maximal-Overlap Allan Variance using Means
#' @description Computation of Maximal-Overlap Allan Variance
#' @usage avar_mo_cpp(x)
#' @param x A \code{vector} with dimensions N x 1. 
#' @return av A \code{list} that contains:
#' \itemize{
#'  \item{"clusters"}{The size of the cluster}
#'  \item{"allan"}{The Allan variance}
#'  \item{"errors"}{The error associated with the variance estimation.}
#' }
#' @details
#' Given \eqn{N} equally spaced samples with averaging time \eqn{\tau = n\tau _0}{tau = n*tau_0},
#' where \eqn{n} is an integer such that \eqn{ 1 \le n \le \frac{N}{2}}{1<= n <= N/2}.
#' Therefore, \eqn{n} is able to be selected from \eqn{\left\{ {n|n < \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}}{{n|n< floor(log2(N))}}
#' Then, \eqn{M = N - 2n} samples exist. 
#' The Maximal-overlap estimator is given by:
#' \eqn{\frac{1}{{2\left( {N - 2k + 1} \right)}}\sum\limits_{t = 2k}^N {{{\left[ {{{\bar Y}_t}\left( k \right) - {{\bar Y}_{t - k}}\left( k \right)} \right]}^2}} }
#' 
#' where \eqn{ {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} }.
#' @author JJB
#' @references Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
#' @examples
#' set.seed(999)
#' # Simulate white noise (P 1) with sigma^2 = 4
#' N = 100000
#' white.noise = rnorm(N, 0, 2)
#' #plot(white.noise,ylab="Simulated white noise process",xlab="Time",type="o")
#' #Simulate random walk (P 4)
#' random.walk = cumsum(0.1*rnorm(N, 0, 2))
#' combined.ts = white.noise+random.walk
#' av_mat = avar_mo_cpp(combined.ts)
avar_mo_cpp <- function(x) {
    .Call('GMWM_avar_mo_cpp', PACKAGE = 'GMWM', x)
}

#' Analytic D matrix for AR(1) process
#' @param phi A \code{double} corresponding to the phi coefficient of an AR(1) process.
#' @param sig2 A \code{double} corresponding to the error term of an AR(1) process.
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{\phi ^2}{sigma^2} and the second column contains the partial derivative with respect to \eqn{\sigma ^2}{sigma^2}
#' @details
#' The haar wavelet variance is given as \eqn{\frac{{\left( {\frac{\tau }{2} - 3{\rho _0} - \frac{{\tau \rho _0^2}}{2} + 4\rho _0^{\frac{\tau }{2} + 1} - \rho _0^{\tau  + 1}} \right)\nu _0^2}}{{\frac{{{\tau ^2}}}{8}{{\left( {1 - {\rho _0}} \right)}^2}\left( {1 - \rho _0^2} \right)}}}{See PDF Manual for equation}
#' Note: \eqn{\phi = \rho}{phi = rho} and \eqn{V _0^2 = \sigma _0^2}{V[0]^2 = sigma[0]^2}.
#' Due to length, the analytical derivations of the AR(1) haar wavelet variance are given in a supplied file within vignette.
#' @author JJB
#' @examples
#' deriv_AR1(.3, 1, 2^(1:5))
deriv_AR1 <- function(phi, sig2, tau) {
    .Call('GMWM_deriv_AR1', PACKAGE = 'GMWM', phi, sig2, tau)
}

#' Analytic second derivative matrix for AR(1) process
#' @param phi A \code{double} corresponding to the phi coefficient of an AR(1) process.
#' @param sig2 A \code{double} corresponding to the error term of an AR(1) process.
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the second partial derivative with respect to \eqn{\phi ^2}{sigma^2} and the second column contains the second partial derivative with respect to \eqn{\sigma ^2}{sigma^2}
#' @details
#' The haar wavelet variance is given as \eqn{\frac{{\left( {\frac{\tau }{2} - 3{\rho _0} - \frac{{\tau \rho _0^2}}{2} + 4\rho _0^{\frac{\tau }{2} + 1} - \rho _0^{\tau  + 1}} \right)\nu _0^2}}{{\frac{{{\tau ^2}}}{8}{{\left( {1 - {\rho _0}} \right)}^2}\left( {1 - \rho _0^2} \right)}}}{See PDF Manual for equation}
#' Note: \eqn{\phi = \rho}{phi = rho} and \eqn{V _0^2 = \sigma _0^2}{V[0]^2 = sigma[0]^2}.
#' Due to length, the analytical derivations of the AR(1) haar wavelet variance are given in a supplied file within vignette.
#' @author JJB
#' @examples
#' deriv_2nd_AR1(.3, 1, 2^(1:5))
deriv_2nd_AR1 <- function(phi, sig2, tau) {
    .Call('GMWM_deriv_2nd_AR1', PACKAGE = 'GMWM', phi, sig2, tau)
}

#' Analytic D matrix for drift process
#' @param omega A \code{double} that is the slope of the drift.
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{\omega _0}{omega[0]}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{{\tau ^2}\omega _0^2}}{2}}{nu^2(tau) = tau^2 omega_0^2 / 2}.
#' Taking the derivative with respect to \eqn{\omega _0^2}{omega_0^2} yields: \eqn{\frac{\partial }{{\partial {\omega _0}}}{\nu ^2}\left( \tau  \right) = {\tau ^2}{\omega _0}}{tau^2 * omega_0}
#' @author JJB
#' @examples
#' deriv_DR(5.3, 2^(1:5))
deriv_DR <- function(omega, tau) {
    .Call('GMWM_deriv_DR', PACKAGE = 'GMWM', omega, tau)
}

#' Analytic second derivative matrix for drift process
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the second partial derivative with respect to \eqn{\omega _0}{omega[0]}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{{\tau ^2}\omega _0^2}}{2}}{nu^2(tau) = tau^2 omega_0^2 / 2}.
#' Taking the derivative with respect to \eqn{\omega _0^2}{omega_0^2} yields: \eqn{\frac{\partial }{{\partial {\omega _0}}}{\nu ^2}\left( \tau  \right) = {\tau ^2}{\omega _0}}{tau^2 * omega_0}
#' Taking second derivative with respect to \eqn{\omega _0^2}{omega_0^2} yields: \eqn{\frac{{{\partial ^2}}}{{\partial \omega _0^2}}{\nu ^2}\left( \tau  \right) = {\tau ^2}}{tau^2}
#' @author JJB
#' @examples
#' deriv_2nd_DR(2^(1:5))
deriv_2nd_DR <- function(tau) {
    .Call('GMWM_deriv_2nd_DR', PACKAGE = 'GMWM', tau)
}

#' Analytic D matrix quantisation noise process
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{Q _0^2}{Q[0]^2}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{3Q_0^2}}{{2{\tau ^2}}}}{nu^2(tau) = 3*Q[0]^2 / 2*tau^2}.
#' Taking the derivative with respect to \eqn{Q _0^2}{Q[0]^2} yields: \deqn{\frac{\partial }{{\partial Q_0^2}}{\nu ^2}\left( \tau  \right) = \frac{3}{{2{\tau ^2}}}}{3/(2*tau^2)}.
#' The second derivative derivative with respect to \eqn{Q _0^2}{Q[0]^2} is then: \deqn{\frac{{{\partial ^2}}}{{\partial Q_0^4}}{\nu ^2}\left( \tau  \right) = 0}{0}.
#' @author JJB
#' @examples
#' deriv_QN(2^(1:5))
deriv_QN <- function(tau) {
    .Call('GMWM_deriv_QN', PACKAGE = 'GMWM', tau)
}

#' Analytic D matrix random walk process
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{\gamma _0^2}{gamma[0]^2}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{\left( {2{\tau ^2} + 1} \right)\gamma _0^2}}{{24\tau }}}{nu^2(tau) = (2*tau^2+1)*gamma^2 / (24*tau)}.
#' Taking the first derivative with respect to \eqn{\gamma _0^2}{gamma_0^2} yields: \deqn{\frac{{{\partial ^2}}}{{\partial \gamma _0^4}}{\nu ^2}\left( \tau  \right) = 0}{(2*tau^2+1) / (24*tau)}
#' The second derivative derivative with respect to \eqn{\gamma _0^2}{gamma[0]^2} is then: \deqn{\frac{{{\partial ^2}}}{{\partial \sigma_0^4}}{\nu ^2}\left( \tau  \right) = 0}{0}.
#' @author JJB
#' @examples
#' deriv_RW(2^(1:5))
deriv_RW <- function(tau) {
    .Call('GMWM_deriv_RW', PACKAGE = 'GMWM', tau)
}

#' Analytic D matrix white noise process
#' @param tau A \code{vec} that contains the scales to be processed (e.g. 2^(1:J))
#' @return A \code{matrix} with the first column containing the partial derivative with respect to \eqn{\sigma _0^2}{sigma[0]^2}.
#' @details
#' The haar wavelet variance is given as \eqn{{\nu ^2}\left( \tau  \right) = \frac{{\sigma _0^2}}{\tau }}{nu^2(tau) = sigma_0^2 / tau}.
#' Taking the derivative with respect to \eqn{\sigma _0^2}{sigma_0^2} yields: \eqn{\frac{\partial }{{\partial \sigma _0^2}}{\nu ^2}\left( \tau  \right) = \frac{1}{\tau }}{1/tau}
#' @author JJB
#' @examples
#' deriv_WN(2^(1:5))
deriv_WN <- function(tau) {
    .Call('GMWM_deriv_WN', PACKAGE = 'GMWM', tau)
}

#' @title Reverse Subset Column
#' @description Subsets the column by going from high indices to low (the reverse of the supported practice)
#' @usage rev_col_subset(x, start, end)
#' @param x A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting column.
#' @param end A \code{unsigned int} that indicates the ending column.
#' @return x A \code{matrix} with matrix rows displayed in reverse order
#' @details Consider a vector x=[[1,2],[3,4]].
#' By setting \code{start=1} and \code{end=0}, the function would output x=[[2,1],[4,1]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix cols start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow = 2,byrow = TRUE)
#' rev_col_subset(x, 1, 0)
rev_col_subset <- function(x, start, end) {
    .Call('GMWM_rev_col_subset', PACKAGE = 'GMWM', x, start, end)
}

#' @title Reverse Subset Row
#' @description Subsets the row by going from high indices to low (the reverse of the supported practice)
#' @usage rev_row_subset(x, start, end)
#' @param x A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting row.
#' @param end A \code{unsigned int} that indicates the ending row.
#' @return x A \code{matrix} with matrix rows displayed in reversed order
#' @details Consider a vector x=[[1,2],[3,4]], the function would output x=[[3,4],[1,2]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix rows start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow=2,byrow=TRUE)
#' rev_row_subset(x, 1, 0)
rev_row_subset <- function(x, start, end) {
    .Call('GMWM_rev_row_subset', PACKAGE = 'GMWM', x, start, end)
}

#' @title Reverse Armadillo Vector
#' @description Reverses the order of an Armadillo Vector
#' @usage reverse_vec(x)
#' @param x A \code{column vector} of length N
#' @return x A \code{column vector} with its contents reversed.
#' @details Consider a vector x=[1,2,3,4,5], the function would output x=[5,4,3,2,1].
#' @author JJB
#' @examples
#' x = 1:5
#' reverse_vec(x)
reverse_vec <- function(x) {
    .Call('GMWM_reverse_vec', PACKAGE = 'GMWM', x)
}

#' @title Transform an Armadillo field<vec> to a matrix
#' @description Unlists vectors in a field and places them into a matrix
#' @param x A \code{field<vec>}.
#' @return A \code{mat} containing the field elements within a column.
#' @author JJB
#' @examples
#' x=rnorm(100)
#' field_to_matrix(modwt_cpp(x))
field_to_matrix <- function(x) {
    .Call('GMWM_field_to_matrix', PACKAGE = 'GMWM', x)
}

#' @title Randomly guess a starting parameter
#' @description Sets starting parameters for each of the given parameters. 
#' @usage guess_initial(signal, w, desc, model_type, num_param, wv_empir, tau, N, B)
#' @param signal A \code{vec} that contains the data
#' @param w A \code{map<string,int>} that lists supported models and the amount in the model.
#' @param model_type A \code{string} that indicates whether it is an SSM or IMU.
#' @param num_params An \code{unsigned int} number of parameters in the model (e.g. # of thetas).
#' @param wv_empir A \code{vec} that contains the empirical wavelet variance.
#' @param tau A \code{vec} that contains the scales. (e.g. 2^(1:J))
#' @param B A \code{integer} that indicates how many random draws that should be performed.
#' @return A \code{vec} containing smart parameter starting guesses to be iterated over.
#' @examples
#' #TBA
NULL

transform_values <- function(theta, desc, objdesc, model_type) {
    .Call('GMWM_transform_values', PACKAGE = 'GMWM', theta, desc, objdesc, model_type)
}

untransform_values <- function(theta, desc, objdesc, model_type) {
    .Call('GMWM_untransform_values', PACKAGE = 'GMWM', theta, desc, objdesc, model_type)
}

gmwm_bootstrapper <- function(theta, desc, objdesc, tau, N, robust, eff, B = 100L) {
    .Call('GMWM_gmwm_bootstrapper', PACKAGE = 'GMWM', theta, desc, objdesc, tau, N, robust, eff, B)
}

ar1_draw <- function(draw_id, last_phi, sigma_tot, model_type) {
    .Call('GMWM_ar1_draw', PACKAGE = 'GMWM', draw_id, last_phi, sigma_tot, model_type)
}

count_AR1s <- function(s) {
    .Call('GMWM_count_AR1s', PACKAGE = 'GMWM', s)
}

#' @title User Specified Initial Values for GMWM Estimator
#' @description This function uses the Generalized Method of Wavelet Moments to estimate the parameters of a time series model.
#' @param theta A \code{vector} with dimensions N x 1 that contains user-supplied initial values for parameters
#' @param desc A \code{vector<string>} indicating the models that should be considered.
#' @param V A \code{matrix} that represents the covariance matrix.
#' @param wv_empir A \code{vector} that contains the empirical wavelet variance
#' @param N A \code{integer} that indicates the length of the signal being studied.
#' @return A \code{vec} that contains the parameter estimates from GMWM estimator.
#' @details
#' The function estimates a variety of time series models. If type = "ARMA" then the parameter vector (param) should
#' indicate the order of the AR process and of the MA process (i.e. param = c(AR,MA)). If type = "IMU" or "SSM", then
#' parameter vector should indicate the characters of the models that compose the latent or state-space model. The model
#' options are:
#' \itemize{
#'   \item{"AR1"}{a first order autoregressive process with parameters \eqn{(\phi,\sigma^2)}{phi, sigma^2}}
#'   \item{"DR"}{a drift with parameter \eqn{\omega}{omega}}
#'   \item{"QN"}{a quantization noise process with parameter \eqn{Q}}
#'   \item{"RW"}{a random walk process with parameter \eqn{\sigma^2}{sigma^2}}
#'   \item{"WN"}{a white noise process with parameter \eqn{\sigma^2}{sigma^2}}
#' }
#' If type = "ARMA", the function takes condition least squares as starting values; if type = "IMU" or type = "SSM" then
#' starting values pass through an initial bootstrap and pseudo-optimization before being passed to the GMWM optimization.
#' If robust = TRUE the function takes the robust estimate of the wavelet variance to be used in the GMWM estimation procedure.
#' 
#' @author JJB
#' @references Wavelet variance based estimation for composite stochastic processes, S. Guerrier and Robust Inference for Time Series Models: a Wavelet-Based Framework, S. Guerrier
#' @keywords internal
#' @examples
#' # Coming soon
adv_gmwm_cpp <- function(theta, desc, objdesc, model_type, V, wv_empir, tau) {
    .Call('GMWM_adv_gmwm_cpp', PACKAGE = 'GMWM', theta, desc, objdesc, model_type, V, wv_empir, tau)
}

sum_field_vec <- function(x) {
    .Call('GMWM_sum_field_vec', PACKAGE = 'GMWM', x)
}

#' @title GMWM for IMU, SSM, and ARMA
#' @description This function uses the Generalized Method of Wavelet Moments to estimate the parameters of a time series model.
#' @param x A \code{vector} with dimensions N x 1. 
#' @param model_type A \code{character string} indicating if the function should estimate an ARMA model ("ARMA"), a model for IMU sensor calibration ("IMU") or a state-space model ("SSM")
#' @param params A \code{vector} being numeric (if type = "ARMA") or character string (if type = "IMU" or type = "SSM")
#' @param robust A \code{bool} indicating if the function should provide a robust estimation of the model parameters (by default = FALSE).
#' @return gmwm A \code{list} that contains:
#' \itemize{
#'  \item{par}{The estimated model parameters}
#'  \item{CI}{The 95\% confidence intervals for the estimated model parameters.}
#' }
#' @details
#' The function estimates a variety of time series models. If type = "ARMA" then the parameter vector (param) should
#' indicate the order of the AR process and of the MA process (i.e. param = c(AR,MA)). If type = "IMU" or "SSM", then
#' parameter vector should indicate the characters of the models that compose the latent or state-space model. The model
#' options are:
#' \itemize{
#'   \item{"AR1"}{a first order autoregressive process with parameters \eqn{(\phi,\sigma^2)}{phi, sigma^2}}
#'   \item{"DR"}{a drift with parameter \eqn{\omega}{omega}}
#'   \item{"QN"}{a quantization noise process with parameter \eqn{Q}}
#'   \item{"RW"}{a random walk process with parameter \eqn{\sigma^2}{sigma^2}}
#'   \item{"WN"}{a white noise process with parameter \eqn{\sigma^2}{sigma^2}}
#' }
#' If type = "ARMA", the function takes condition least squares as starting values; if type = "IMU" or type = "SSM" then
#' starting values pass through an initial bootstrap and pseudo-optimization before being passed to the GMWM optimization.
#' If robust = TRUE the function takes the robust estimate of the wavelet variance to be used in the GMWM estimation procedure.
#' 
#' @author JJB
#' @references Wavelet variance based estimation for composite stochastic processes, S. Guerrier and Robust Inference for Time Series Models: a Wavelet-Based Framework, S. Guerrier
#' @keywords internal
#' @examples
#' # Coming soon
gmwm_cpp <- function(signal, desc, objdesc, model_type, V, wv_empir, tau, B = 1000L) {
    .Call('GMWM_gmwm_cpp', PACKAGE = 'GMWM', signal, desc, objdesc, model_type, V, wv_empir, tau, B)
}

#' @title Computes the (MODWT) wavelet covariance matrix
#' @description Calculates the (MODWT) wavelet covariance matrix
#' @param signal_modwt A \code{field<vec>} that contains the modwt decomposition.
#' @param nb_level A \code{integer} that contains the level of decomposition J.
#' @param compute_v A \code{string} that indicates what kind of matrix should be created. Possible options: "diag" or "none"
#' @param robust A \code{boolean} that triggers the use of the robust estimate.
#' @param eff A \code{double} that indicates the efficiency as it relates to an MLE.
#' @return A \code{field<mat>} containing the covariance matrix.
#' @examples
#' \dontrun{
#' x=rnorm(100)
#' decomp = modwt(x)
#' V = compute_cov_cpp(decomp$data, decomp$nlevels, compute_v="diag", robust = TRUE, eff=0.6)
#' }
compute_cov_cpp <- function(signal_modwt, nb_level, compute_v = "diag", robust = TRUE, eff = 0.6) {
    .Call('GMWM_compute_cov_cpp', PACKAGE = 'GMWM', signal_modwt, nb_level, compute_v, robust, eff)
}

#' @title Discrete Wavelet Transform
#' @description Calculation of the coefficients for the discrete wavelet transformation. 
#' @usage dwt_cpp(x, filter_name, nlevels, boundary)
#' @param x A \code{vector} with dimensions \eqn{N\times 1}{N x 1}. 
#' @param filter_name A \code{string} indicating the filter.
#' @param nlevels An \code{integer}, \eqn{J}, indicating the level of the decomposition.
#' @param boundary A \code{string} indicating the type of boundary method to use. Either \code{boundary="periodic"} or \code{"reflection"}.
#' @return y A \code{field<vec>} that contains the wavelet coefficients for each decomposition level
#' @details
#' Performs a level J decomposition of the time series using the pyramid algorithm
#' @author JJB
#' @examples
#' set.seed(999)
#' x = rnorm(2^8)
#' dwt_cpp(x, "haar", 4, boundary="periodic")
dwt_cpp <- function(x, filter_name = "haar", nlevels = 4L, boundary = "periodic") {
    .Call('GMWM_dwt_cpp', PACKAGE = 'GMWM', x, filter_name, nlevels, boundary)
}

#' @title Maximum Overlap Discrete Wavelet Transform
#' @description Calculation of the coefficients for the discrete wavelet transformation
#' @usage modwt_cpp(x, filter_name, nlevels, boundary)
#' @param x A \code{vector} with dimensions N x 1. 
#' @param filter_name A \code{string} indicating the filter.
#' @param nlevels An \code{integer} indicating the level of the decomposition.
#' @param boundary A \code{string} indicating the type of boundary method to use. Either \code{boundary="periodic"} or \code{"reflection"}.
#' @return y A \code{field<vec>} that contains the wavelet coefficients for each decomposition level
#' @details
#' Performs a level J decomposition of the time series using the pyramid algorithm.
#' Use this implementation to supply custom parameters instead of modwt(x),
#' which serves as a wrapper function.
#' @author JJB
#' @examples
#' set.seed(999)
#' x = rnorm(100)
#' modwt_cpp(x, "haar", 4, boundary="periodic")
modwt_cpp <- function(x, filter_name = "haar", nlevels = 4L, boundary = "periodic") {
    .Call('GMWM_modwt_cpp', PACKAGE = 'GMWM', x, filter_name, nlevels, boundary)
}

#' @title Removal of Boundary Wavelet Coefficients
#' @description Removes the first n wavelet coefficients.
#' @param x A \code{field<vec>} that contains the nlevel decomposition using either modwt or dwt.
#' @param wave_filter A \code{field<vec>} containing filter information. Only "haar" is implemented.
#' @param method A \code{string} to describe the mode. Choose between "modwt" and "dwt"
#' @return A \code{field<vec>} with boundary modwt or dwt taken care of.
#' @details 
#' The vectors are truncated by removing the first n wavelet coefficients. 
#' These vectors are then stored into the field that is returned.
#' Note: As a result, there are no NA's introduced and hence the na.omit is not needed.
#' @examples
#' x=rnorm(100)
#' brick_wall(modwt_cpp(x, "haar", 4, boundary="periodic"), select_filter("haar"), "modwt")
brick_wall <- function(x, wave_filter, method = "modwt") {
    .Call('GMWM_brick_wall', PACKAGE = 'GMWM', x, wave_filter, method)
}

#' @title Generate a white noise process
#' @description Generates a white noise process with variance parameter sigma.
#' @param N An \code{integer} for signal length.
#' @param sigma2 A \code{double} that contains process variance.
#' @return wn A \code{vec} containing the white noise.
#' @examples
#' gen_wn(10, 1.5)
gen_wn <- function(N, sigma2 = 1) {
    .Call('GMWM_gen_wn', PACKAGE = 'GMWM', N, sigma2)
}

#' @title Generate a drift
#' @description Generates a drift sequence with a given slope.
#' @param N An \code{integer} for signal length.
#' @param slope A \code{double} that contains drift slope
#' @return gd A \code{vec} containing the drift.
#' @examples
#' gen_dr(10, 8.2)
gen_dr <- function(N, slope = 5) {
    .Call('GMWM_gen_dr', PACKAGE = 'GMWM', N, slope)
}

#' @title Generate a Quantisation Noise (QN) sequence
#' @description Generate an QN sequence given q2
#' @param N An \code{integer} for signal length.
#' @param q2 A \code{double} that contains autocorrection.
#' @return  A \code{vec} containing the QN process.
#' @details 
#' To generate the quantisation noise, we follow this recipe:
#' First, we generate using a random uniform distribution:
#' \deqn{U_k^*\sim U\left[ {0,1} \right]}{U_k^*~U[0,1]}
#' 
#' Then, we multiple the sequence by \eqn{\sqrt{12}}{sqrt(12)} so:
#' \deqn{{U_k} = \sqrt{12} U_k^*}{U_k = sqrt(12)*U_k^*}
#' 
#' Next, we find the derivative of \eqn{{U_k}}{U_k}
#' \deqn{{{\dot U}_k} = \frac{{{U_{k + \Delta t}} - {U_k}}}{{\Delta t}}}{U_k^. = (U_(k + (delta)t) - U_k)}
#'
#' In this case, we modify the derivative such that:
#' \eqn{{{\dot U}_k}\Delta t = {U_{k + \Delta t}} - {U_k}}{U_k^. * (delta)t = U_{k + (delta)*t} - U_k}
#'
#' Thus, we end up with:
#' \deqn{{x_k} = \sqrt Q {{\dot U}_k}\Delta t}{x_k = sqrt(Q)*U_k^.*(delta)t}
#' \deqn{{x_k} = \sqrt Q \left( {{U_{k + 1}} - {U_k}} \right)}{x_k = sqrt(Q)* (U_(k+1) - U_(k))}
#'
#' @examples
#' gen_qn(10, 5)
gen_qn <- function(N, q2 = .1) {
    .Call('GMWM_gen_qn', PACKAGE = 'GMWM', N, q2)
}

#' @title Generate an AR(1) sequence
#' @description Generate an AR sequence given phi and sig2.
#' @details This needs to be extended to AR(p) see \code{arima.sim} and \code{filter}.
#' @param N An \code{integer} for signal length.
#' @param phi A \code{double} that contains autocorrection.
#' @param sigma2 A \code{double} that contains process variance.
#' @return gm A \code{vec} containing the AR(1) process.
#' @examples
#' gen_ar1(10, 5, 1.2)
gen_ar1 <- function(N, phi = .3, sigma2 = 1) {
    .Call('GMWM_gen_ar1', PACKAGE = 'GMWM', N, phi, sigma2)
}

#' @title Generate a random walk without drift
#' @description Generates a random walk without drift.
#' @param N An \code{integer} for signal length.
#' @param sigma2 A \code{double} that contains process variance.
#' @return grw A \code{vec} containing the random walk without drift.
#' @examples
#' gen_rw(10, 8.2)
gen_rw <- function(N, sigma2 = 1) {
    .Call('GMWM_gen_rw', PACKAGE = 'GMWM', N, sigma2)
}

#' @title ARMA process to WV
#' @description This function computes the (haar) WV of an ARMA process
#' @param ar A \code{vec} containing the coefficients of the AR process
#' @param ma A \code{vec} containing the coefficients of the MA process
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @param sigma A \code{double} containing the residual variance
#' @return A \code{vec} containing the wavelet variance of the ARMA process.
#' @examples
#' arma_to_wv(c(.23,.43), c(.34,.41,.59), 2^(1:9), 3)
#' @seealso \code{\link{ARMAtoMA_cpp}},\code{\link{ARMAacf_cpp}}
arma_to_wv <- function(ar, ma, tau, sigma) {
    .Call('GMWM_arma_to_wv', PACKAGE = 'GMWM', ar, ma, tau, sigma)
}

#' @title Quantisation Noise to WV
#' @description This function compute the WV (haar) of a Quantisation Noise (QN) process
#' @param q2 A \code{double} corresponding to variance of drift
#' @param Tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the QN.
#' @examples
#' x.sim = 1:1000
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = qn_to_wv(1, tau)
#' plot(tau, wv.theo, col = "red")
qn_to_wv <- function(q2, tau) {
    .Call('GMWM_qn_to_wv', PACKAGE = 'GMWM', q2, tau)
}

#' @title White Noise to WV
#' @description This function compute the WV (haar) of a White Noise process
#' @param sig2 A \code{double} corresponding to variance of WN
#' @param Tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the white noise.
#' @examples
#' x.sim = cumsum(rnorm(100000))
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = wn_to_wv(1, tau)
#' plot(tau, wv.theo, col = "red")
wn_to_wv <- function(sig2, tau) {
    .Call('GMWM_wn_to_wv', PACKAGE = 'GMWM', sig2, tau)
}

#' @title Random Walk to WV
#' @description This function compute the WV (haar) of a Random Walk process
#' @param sig2 A \code{double} corresponding to variance of RW
#' @param Tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the random walk.
#' @examples
#' x.sim = cumsum(rnorm(100000))
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = rw_to_wv(1,tau)
#' plot(tau, wv.theo, col = "red")
rw_to_wv <- function(sig2, tau) {
    .Call('GMWM_rw_to_wv', PACKAGE = 'GMWM', sig2, tau)
}

#' @title Drift to WV
#' @description This function compute the WV (haar) of a Drift process
#' @param omega A \code{double} corresponding to variance of drift
#' @param Tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the drift.
#' @examples
#' x.sim = 1:1000
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = dr_to_wv(1, tau)
#' plot(tau, wv.theo, col = "red")
dr_to_wv <- function(omega, tau) {
    .Call('GMWM_dr_to_wv', PACKAGE = 'GMWM', omega, tau)
}

#' @title AR1 process to WV
#' @description This function compute the WV (haar) of an AR(1) process
#' @param phi A \code{double} that is the phi term of the AR(1) process
#' @param sig2 A \code{double} corresponding to variance of AR(1) process
#' @param tau A \code{vec} containing the scales e.g. 2^tau
#' @return A \code{vec} containing the wavelet variance of the AR(1) process.
#' @examples
#' x.sim = gen_ar1( N = 10000, phi = 0.9, sigma2 = 4 )
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = ar1_to_wv(phi = 0.9, sig2 = 16, tau)
#' plot(tau, wv.theo, col = "red")
ar1_to_wv <- function(phi, sig2, tau) {
    .Call('GMWM_ar1_to_wv', PACKAGE = 'GMWM', phi, sig2, tau)
}

#' @title Model Process to WV
#' @description This function computes the summation of all Processes to WV (haar) in a given model
#' @param theta A \code{vec} containing the list of estimated parameters.
#' @param desc A \code{vector<string>} containing a list of descriptors.
#' @param nparams A \code{vec} containing the number of parameters per process described in desc.
#' @param tau A \code{vec} containing the scales e.g. 2^(1:J)
#' @param N An \code{integer} containing the number of elements in the time series.
#' @return A \code{vec} containing the wavelet variance of the AR(1) process.
#' @examples
#' x.sim = gen_ar1( N = 10000, phi = 0.9, sigma2 = 4 )
#' ntau = floor(log(length(x.sim),2))
#' tau = 2^(1:ntau)
#' wv.theo = ar1_to_wv(phi = 0.9, sig2 = 16, tau)
#' plot(tau, wv.theo, col = "red")
theoretical_wv <- function(theta, desc, objdesc, tau) {
    .Call('GMWM_theoretical_wv', PACKAGE = 'GMWM', theta, desc, objdesc, tau)
}

#' @title Lagged Differences in Armadillo
#' @description Returns the ith difference of a time series of rth lag.
#' @param x A \code{vec} that is the time series
#' @param lag A \code{unsigned int} that indicates the lag
#' @param differences A \code{dif} that indicates how many differences should be taken
#' @return A \code{vector} containing the differenced time series.
#' @author JJB
#' @examples
#' x = rnorm(10000, 0, 1)
#' diff_cpp(x,1,1)
diff_cpp <- function(x, lag, differences) {
    .Call('GMWM_diff_cpp', PACKAGE = 'GMWM', x, lag, differences)
}

#' @title Converting an ARMA Process to an Infinite MA Process
#' @description Takes an ARMA function and converts it to an infinite MA process.
#' @param ar A \code{column vector} of length p
#' @param ma A \code{column vector} of length q
#' @param lag_max A \code{int} of the largest MA(Inf) coefficient required.
#' @return A \code{column vector} containing coefficients
#' @details This function is a port of the base stats package's ARMAtoMA. There is no significant speed difference between the two.
#' @author R Core Team and JJB
#' @examples
#' # ARMA(2,1)
#' ARMAtoMA_cpp(c(1.0, -0.25), 1.0, 10)
#' # ARMA(0,1)
#' ARMAtoMA_cpp(numeric(0), 1.0, 10)
ARMAtoMA_cpp <- function(ar, ma, lag_max) {
    .Call('GMWM_ARMAtoMA_cpp', PACKAGE = 'GMWM', ar, ma, lag_max)
}

#' @title Time Series Convolution Filters
#' @description Applies a convolution filter to a univariate time series.
#' @param x A \code{column vector} of length T
#' @param filter A \code{column vector} of length f
#' @param sides An \code{int} that takes either 1:for using past values only or 2: filter coefficients are centered around lag 0.
#' @param circular A \code{bool} that indicates if the filter should be wrapped around the ends of the time series.
#' @return A \code{column vec} that contains the results of the filtering process.
#' @details This is a port of the cfilter function harnessed by the filter function in stats. 
#' It is about 5-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' x = 1:100
#' # 
#' cfilter(x, rep(1, 3), sides = 2, circular = FALSE)
#' # Using R's function
#' filter(x, rep(1, 3))
#' #
#' cfilter(x, rep(1, 3), sides = 1, circular = FALSE)
#' # Using R's function
#' filter(x, rep(1, 3), sides = 1)
#' #
#' cfilter(x, rep(1, 3), sides = 1, circular = TRUE)
#' # Using R's function
#' filter(x, rep(1, 3), sides = 1, circular = TRUE)
cfilter <- function(x, filter, sides, circular) {
    .Call('GMWM_cfilter', PACKAGE = 'GMWM', x, filter, sides, circular)
}

#' @title Time Series Recursive Filters
#' @description Applies a recursive filter to a univariate time series.
#' @usage rfilter(x, filter, init)
#' @param x A \code{column vector} of length T
#' @param filter A \code{column vector} of length f
#' @param init A \code{column vector} of length f that contains the initial values of the time series in reverse.
#' @return x A \code{column vector} with its contents reversed.
#' @details Note: The length of 'init' must be equal to the length of 'filter'.
#' This is a port of the rfilter function harnessed by the filter function in stats. 
#' It is about 6-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' x = 1:100
#' # 
#' rfilter(x, rep(1, 3), rep(1, 3))
#' # Using R's function
#' filter(x, rep(1, 3), method="recursive", init=rep(1, 3))
rfilter <- function(x, filter, init) {
    .Call('GMWM_rfilter', PACKAGE = 'GMWM', x, filter, init)
}

#' @title Compute Theoretical ACF for an ARMA Process
#' @description Compute the theoretical autocorrelation function for an ARMA process.
#' @usage ARMAacf_cpp(ar,ma,lag_max)
#' @param ar A \code{vector} of length p containing AR coefficients
#' @param ma A \code{vector} of length q containing MA coefficients
#' @param lag_max A \code{unsigned integer} indicating the maximum lag necessary
#' @return x A \code{matrix} listing values from 1...nx in one column and 1...1, 2...2,....,n...n, in the other
#' @details This is an implementaiton of the ARMAacf function in R. It is approximately 40x times faster. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
#' @author R Core Team and JJB
#' @examples
#' # ARMA(2,1)
#' ARMAacf_cpp(c(1.0, -0.25), 1.0, lag_max = 10)
#' # ARMA(0,1)
#' ARMAacf_cpp(numeric(0), .35, lag_max = 10)
ARMAacf_cpp <- function(ar, ma, lag_max) {
    .Call('GMWM_ARMAacf_cpp', PACKAGE = 'GMWM', ar, ma, lag_max)
}

#' @title Absolute Value or Modulus of a Complex Number Squared.
#' @description Computes the squared value of the Modulus.
#' @param x A \code{cx_vec}. 
#' @return A \code{vec} containing the modulus squared for each element.
#' @details Consider a complex number defined as: \eqn{z = x + i y} with real \eqn{x} and \eqn{y},
#' The modulus is defined as: \eqn{r = Mod\left(z\right) = \sqrt{\left(x^2 + y^2\right)}}{r = Mod(z) = sqrt(x^2 + y^2)}
#' This function will return: \eqn{r^2 = Mod\left(z\right)^2 = x^2 + y^2}
#' @examples
#' Mod_squared_cpp(c(1+.5i, 2+1i, 5+9i))
Mod_squared_cpp <- function(x) {
    .Call('GMWM_Mod_squared_cpp', PACKAGE = 'GMWM', x)
}

#' @title Absolute Value or Modulus of a Complex Number.
#' @description Computes the value of the Modulus.
#' @param x A \code{cx_vec}. 
#' @return A \code{vec} containing the modulus for each element.
#' @details Consider a complex number defined as: \eqn{z = x + i y} with real \eqn{x} and \eqn{y},
#' The modulus is defined as: \eqn{r = Mod(z) = \sqrt{(x^2 + y^2)}}
#' @examples
#' Mod_cpp(c(1+.5i, 2+1i, 5+9i))
Mod_cpp <- function(x) {
    .Call('GMWM_Mod_cpp', PACKAGE = 'GMWM', x)
}

#' @title Discrete Fourier Transformation for Autocovariance Function
#' @description Calculates the autovariance function (ACF) using Discrete Fourier Transformation.
#' @param x A \code{cx_vec}. 
#' @return A \code{vec} containing the ACF.
#' @details 
#' This implementation is 2x as slow as Rs. 
#' Two issues: 1. memory resize and 2. unoptimized fft algorithm in arma.
#' Consider piping back into R and rewrapping the object. (Decrease of about 10 microseconds.)
#' @examples
#' x=rnorm(100)
#' dft_acf(x)
dft_acf <- function(x) {
    .Call('GMWM_dft_acf', PACKAGE = 'GMWM', x)
}

#' @title Pseudo Logit Inverse Function
#' @description This function computes the pseudo inverse of a logit transformation of the parameters in order to constrain them to a positive domain 
#' @param x A \code{vec} containing real numbers.
#' @return A \code{vec} containing logit probabilities.
#' @examples
#' x.sim = rnorm(100)
#' pseudo_logit_inv(x.sim)
pseudo_logit_inv <- function(x) {
    .Call('GMWM_pseudo_logit_inv', PACKAGE = 'GMWM', x)
}

#' @title Logit Inverse Function
#' @description This function computes the inverse of a logit transformation of the parameters.
#' @param x A \code{vec} containing real numbers.
#' @return A \code{vec} containing logit probabilities.
#' @examples
#' x.sim = rnorm(100)
#' logit_inv(x.sim)
logit_inv <- function(x) {
    .Call('GMWM_logit_inv', PACKAGE = 'GMWM', x)
}

#' @title Pseudo Logit Function
#' @description This function compute the link function to constrain parameters to a positive domain.
#' @param x A \code{vec} containing probabilities (e.g. 0 <= x <= 1)
#' @return A \code{vec} containing logit terms.
#' @examples
#' x.sim = runif(100)
#' pseudo_logit(x.sim)
pseudo_logit <- function(x) {
    .Call('GMWM_pseudo_logit', PACKAGE = 'GMWM', x)
}

#' @title Logit Function
#' @description This function computes the logit link function.
#' @param x A \code{vec} containing probabilities (e.g. 0 <= x <= 1)
#' @return A \code{vec} containing logit terms.
#' @examples
#' x.sim = runif(100)
#' logit(x.sim)
logit <- function(x) {
    .Call('GMWM_logit', PACKAGE = 'GMWM', x)
}

#' @title Generate eta3 confidence interval
#' @description Computes the eta3 CI
#' @param y A \code{vec} that computes the brickwalled modwt dot product of each wavelet coefficient divided by their length.
#' @param dims A \code{String} indicating the confidence interval being calculated.
#' @param p A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level 
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @examples
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, "haar", 4, "periodic")
#' signal_modwt_bw = brick_wall(decomp, select_filter("haar"), "modwt")
#' y = wave_variance(signal_modwt_bw)
#' ci_wave_variance(signal_modwt_bw, y, type = "eta3", p = 0.025)
ci_eta3 <- function(y, dims, p) {
    .Call('GMWM_ci_eta3', PACKAGE = 'GMWM', y, dims, p)
}

#' @title Generate eta3 robust confidence interval
#' @description Computes the eta3 robust CI
#' @param y A \code{vec} that computes the brickwalled modwt dot product of each wavelet coefficient divided by their length.
#' @param dims A \code{String} indicating the confidence interval being calculated.
#' @param p A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level
#' @param eff A \code{double} that indicates the efficiency.
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Robust Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @examples
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, "haar", 4, boundary="periodic")
#' signal_modwt_bw = brick_wall(decomp, select_filter("haar"), "modwt")
#' y = wave_variance(signal_modwt_bw, robust = TRUE,  eff = 0.6)
#' ci_wave_variance(signal_modwt_bw, y, type = "eta3", p = 0.025, robust = TRUE, eff = 0.6)
ci_eta3_robust <- function(y, dims, p, eff) {
    .Call('GMWM_ci_eta3_robust', PACKAGE = 'GMWM', y, dims, p, eff)
}

#' @title Generate a Confidence intervval for a Univariate Time Series
#' @description Computes an estimate of the multiscale variance and a chi-squared confidence interval
#' @param signal_modwt_bw A \code{field<vec>} that contains the brick walled modwt or dwt decomposition
#' @param y A \code{vec} that contains the wave variance.
#' @param type A \code{String} indicating the confidence interval being calculated.
#' @param p A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level.
#' @param robust A \code{boolean} to determine the type of wave estimation.
#' @param eff A \code{double} that indicates the efficiency.
#' @return A \code{matrix} with the structure:
#' \itemize{
#'  \item{Column 1}{Wavelet Variance}
#'  \item{Column 2}{Chi-squared Lower Bounds}
#'  \item{Column 3}{Chi-squared Upper Bounds}
#' }
#' @details 
#' This function can be expanded to allow for other confidence interval calculations.
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' # Uses the internal MODWT function not associated with an S3 class.
#' decomp = modwt_cpp(x, "haar", 4, boundary="periodic")
#' signal_modwt_bw = brick_wall(decomp, select_filter("haar"), "modwt")
#' y = wave_variance(signal_modwt_bw)
#' ci_wave_variance(signal_modwt_bw, y, type = "eta3", p = 0.025)
ci_wave_variance <- function(signal_modwt_bw, y, type = "eta3", p = 0.025, robust = FALSE, eff = 0.6) {
    .Call('GMWM_ci_wave_variance', PACKAGE = 'GMWM', signal_modwt_bw, y, type, p, robust, eff)
}

#' @title Generate a Wave Variance for a Univariate Time Series
#' @description Computes an estimate of the wave variance
#' @param signal_modwt_bw A \code{field<vec>} that contains the brick walled modwt or dwt decomposition
#' @param robust A \code{boolean} to determine the type of wave estimation.
#' @param eff A \code{double} that indicates the efficiency.
#' @return A \code{vec} that contains the wave variance.
#' @examples
#' set.seed(1337)
#' x = rnorm(100)
#' signal_modwt_bw = brick_wall(modwt_cpp(x), haar_filter())
#' wave_variance(signal_modwt_bw)
#' 
#' wave_variance(signal_modwt_bw, robust = TRUE, eff = 0.6)
wave_variance <- function(signal_modwt_bw, robust = FALSE, eff = 0.6) {
    .Call('GMWM_wave_variance', PACKAGE = 'GMWM', signal_modwt_bw, robust, eff)
}

#' @title Computes the (MODWT) wavelet variance
#' @description Calculates the (MODWT) wavelet variance
#' @param signal_modwt A \code{field<vec>} that contains the modwt decomposition.
#' @param robust A \code{boolean} that triggers the use of the robust estimate.
#' @param eff A \code{double} that indicates the efficiency as it relates to an MLE.
#' @param p A \code{double} that indicates the \eqn{\left(1-p\right)*\alpha}{(1-p)*alpha} confidence level 
#' @param ci_type A \code{String} indicating the confidence interval being calculated. Valid value: "eta3"
#' @param strWavelet A \code{String} indicating the type of wave filter to be applied. Must be "haar"
#' @return A \code{mat} with the structure:
#' \itemize{
#'   \item{"variance"}{Wavelet Variance}
#'   \item{"low"}{Lower CI}
#'   \item{"high"}{Upper CI}
#' }
#' @details 
#' This function powers the wvar object. It is also extendable...
#' @examples
#' x=rnorm(100)
#' decomp = modwt(x)
#' wvar_cpp(decomp$data, robust = FALSE)
wvar_cpp <- function(signal_modwt, robust = FALSE, eff = 0.6, p = 0.025, ci_type = "eta3", strWavelet = "haar") {
    .Call('GMWM_wvar_cpp', PACKAGE = 'GMWM', signal_modwt, robust, eff, p, ci_type, strWavelet)
}

#' @title Computes the MODWT scales
#' @description Calculates the MODWT scales
#' @param nb_level A \code{integer} that contains the level of decomposition J.
#' @return A \code{vec} that contains 2^1, ... , 2^J
#' @details 
#' Used in wvar object.
#' @examples
#' scales_cpp(5)
scales_cpp <- function(nb_level) {
    .Call('GMWM_scales_cpp', PACKAGE = 'GMWM', nb_level)
}

#' @title Quadrature Mirror Filter
#' @description Calculate the series quadrature mirror filter (QMF). Requires a series of an even length.
#' @usage qmf(g, inverse)
#' @param g A \code{vector} that contains the filter constants.
#' @param inverse A \code{bool} that indicates whether the inverse quadrature mirror filter is computed. 
#' By default, the inverse quadrature mirror is computed.
#' @return A \code{vector} that contains either the forward QMF (evalute in order) or the inverse QMF (reverse order). 
#' @author JJB
#' @examples
#' # Haar values
#' g = rep(1/sqrt(2),2)
#' qmf(g)
qmf <- function(g, inverse = TRUE) {
    .Call('GMWM_qmf', PACKAGE = 'GMWM', g, inverse)
}

#' @title Haar filter construction
#' @description Creates the haar filter
#' @usage haar_filter()
#' @return A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details
#' This template can be used to increase the amount of filters available for selection.
#' @author JJB
#' @examples
#' haar_filter()
haar_filter <- function() {
    .Call('GMWM_haar_filter', PACKAGE = 'GMWM')
}

#' @title Select the Wavelet Filter
#' @description Constructs the wavelet filter to be used.
#' @usage select_filter(filter_name)
#' @param filter_name A \code{String} that must receive: \code{"haar"}.
#' @return info A \code{field<vec>} that contains:
#' \itemize{
#'  \item{"L"}{A \code{integer} specifying the length of the filter}
#'  \item{"h"}{A \code{vector} containing the coefficients for the wavelet filter}
#'  \item{"g"}{A \code{vector} containing the coefficients for the scaling filter}
#' }
#' @details 
#' The package is oriented toward using only the haar filter. If the package extends at a later time, then the supporting infrastructure is there.
#' @author JJB
#' @examples
#' select_filter("haar")
select_filter <- function(filter_name = "haar") {
    .Call('GMWM_select_filter', PACKAGE = 'GMWM', filter_name)
}

